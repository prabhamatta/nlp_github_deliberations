issue_id	comment_id	created_at	comment_url	comment_user	mentioned_user	comment_text
3294	29035854	2013-11-21T23:39:16Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29035854	gavinandresen	Diapolo	@Diapolo: good catch on the -1.  init.cpp doesn't mention gen/genproclimit, since generating blocks is a developer-only feature (we don't want people thinking they can successfully CPU mine on the main network).
3294	29119945	2013-11-23T00:17:58Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29119945	gavinandresen	sipa	@sipa: number of threads is ignored in regtest mode already (one thread is used, and it exits as soon as a block is found).    If you like, you can think of it as "Start N threads, and exit each as soon as a block is found."  That isn't actually how it is implemented, of course (blocks are found so quickly the N threads would stomp on each other's blocks)...    I'm normally sympathetic to "makes RPC ugly" arguments, but since setgenerate is ONLY for developers/testing/debugging I think ugly is just fine here.
3292	28976556	2013-11-21T11:31:16Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28976556	laanwj	fanquake	Thanks @fanquake
3286	29006854	2013-11-21T17:55:19Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29006854	Diapolo	laanwj	@laanwj Am I right that MaxAddressLength is not the MinAddressLength ;)? And if this is the case, what is the minimum length of a BTC address? This is not yet mergable in the current state ^^.
3286	29055366	2013-11-22T08:07:23Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29055366	Diapolo	laanwj	@laanwj Re-worked, can you check for correctness?
3285	29007831	2013-11-21T18:05:50Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29007831	Diapolo	laanwj	I have more string and translations updates, but don't want to bloat this pull, so it get's merged faster.  @laanwj Can you take a look please?
3284	28979434	2013-11-21T12:20:55Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28979434	laanwj	sipa	@sipa @gmaxwell @gavinandresen Can I get some acks here please?
3284	28979434	2013-11-21T12:20:55Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28979434	laanwj	gmaxwell	@sipa @gmaxwell @gavinandresen Can I get some acks here please?
3284	28979434	2013-11-21T12:20:55Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28979434	laanwj	gavinandresen	@sipa @gmaxwell @gavinandresen Can I get some acks here please?
3276	29069119	2013-11-22T12:32:02Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29069119	sipa	gavinandresen	@gavinandresen @gmaxwell Some ACKs?
3276	29069119	2013-11-22T12:32:02Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29069119	sipa	gmaxwell	@gavinandresen @gmaxwell Some ACKs?
3271	28644305	2013-11-17T07:41:25Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28644305	laanwj	jgarzik	@jgarzik That's also why I have discouraged doing this.    On the other hand, it appears pretty trivial to rebase patches to this and it mostly (only) affects debug printing.
3271	28677269	2013-11-18T06:07:16Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28677269	brandondahler	sipa	@sipa and @laanwj:  following your suggestions, I have created the Log class (log.h and log.cpp).  At its core it works by multiplexing an input to multiple outputs.      Since generally flags won't change after instantiation of the class (except for changes from other threads), the constructor of the instantiation reads the different flags and decides what streams to send the data to.    For all types except strings and const char*s, the data is just passed along to the streams below (manipulators work too).  For strings and const char*s, we do a little processing based on what stream it is, specifically seeing if/when we are writing new lines.      For the error function, I removed it all-together and replaced them with log calls ("ERROR: " prepended, "\n" appened).  If we want to make it so the "ERROR: " part is configurable, I would recommend a public static const char* on Log instead of making a wrapping function.
3271	28677269	2013-11-18T06:07:16Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28677269	brandondahler	laanwj	@sipa and @laanwj:  following your suggestions, I have created the Log class (log.h and log.cpp).  At its core it works by multiplexing an input to multiple outputs.      Since generally flags won't change after instantiation of the class (except for changes from other threads), the constructor of the instantiation reads the different flags and decides what streams to send the data to.    For all types except strings and const char*s, the data is just passed along to the streams below (manipulators work too).  For strings and const char*s, we do a little processing based on what stream it is, specifically seeing if/when we are writing new lines.      For the error function, I removed it all-together and replaced them with log calls ("ERROR: " prepended, "\n" appened).  If we want to make it so the "ERROR: " part is configurable, I would recommend a public static const char* on Log instead of making a wrapping function.
3271	28862460	2013-11-20T04:10:50Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28862460	brandondahler	gavinandresen	@gavinandresen:  I understand feeling that there is a lot of one-time risk involved in moving from printf to stream style conversion; however, I completely disagree that there is no practical benefit.    1)  This makes maintenance easier    The code is much less complex overall.  This removes some ugly compatibility #defines, attribute markings, and even hacks.    2)  Platform independence    We are no longer relying on the platform to have a correct/compliant printf function.  Instead we are relying on the C++ standard library implementation which we already rely on since we use C++ in the first place.  This is specifically a problem for int64_t since Windows doesn't use the same syntax as Linux unless you use some compatibility defines.    3)  The way it reads    Streams read fluently instead of requiring the user to place the parameters in the correct place.  Consider:        return strprintf(              "HTTP/1.1 %d %s\r\n"              "Date: %s\r\n"              "Connection: %s\r\n"              "Content-Length: %"PRIszu"\r\n"              "Content-Type: application/json\r\n"              "Server: bitcoin-json-rpc/%s\r\n"              "\r\n"              "%s",          nStatus,          cStatus,          rfc1123Time().c_str(),          keepalive ? "keep-alive" : "close",          strMsg.size(),          FormatFullVersion().c_str(),          strMsg.c_str());    Becomes        ossReply << "HTTP/1.1 " << nStatus << " " << cStatus << "\r\n"               << "Date: " << rfc1123Time() << "\r\n"               << "Connection: " << (keepalive ? "keep-alive" : "close") << "\r\n"               << "Content-Length: " << strMsg.size() << "\r\n"               << "Content-Type: application/json\r\n"               << "Server: bitcoin-json-rpc/" << FormatFullVersion() << "\r\n"               << "\r\n"               << strMsg;      return ossReply.str();    Likewise logging lines stand out just like normal cout lines (given the new Log class).    ____    All of this being said, I will agree that the shorter changes, such as:        std::string tmpfn = strprintf("peers.dat.%04x", randv);    Becoming        std::ostringstream tmpfn("peers.dat.");      tmpfn << std::hex << std::setfill('0') << std::setw(4) << randv << std::dec << std::setfill(' ');    Would probably work better off as a boost::format.  The reason I started out with not using boost::format more is because I personally prefer to keep dependence on boost to a minimum.  If y'all disagree I do think it could make things less cluttered when making simple, smalls strings.      Likewise creating formatting functions for specific types of data would allow us to change the output formatting of the data in one place instead of across a bunch of files, while fitting in with the stream style.  Using the above function again, having a static call makes things cleaner all-together:        ...      std::string tmpfn = CAddrDB::PeersFilePath(randv);      ...        std::string CAddrDB::PeersFilePath(unsigned short randv)      {          std::ostringstream tmpfn();          tmpfn << "peers.dat." << std::hex << std::setfill('0') << std::setw(4) << randv;          return tmpfn.str();      }    Further we can make custom manipulators to reduce duplication of code:        ios_base& hex04(ios_base& ib)      {          ib << std::hex << std::setfill('0') << std::setw(4);          return ib;      }            std::string CAddrDB::PeersFilePath(unsigned short randv)      {          std::ostringstream tmpfn();          tmpfn << "peers.dat." << hex04 << randv;          return tmpfn.str();      }
3271	28867775	2013-11-20T07:07:09Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28867775	laanwj	gavinandresen	@gavinandresen Agreed, the problem isn't with printf-style *syntax*, it's with the printf function  - which (in our usage) isn't part of the C++ standard, so we had a dependency on C99-like formats that broke down on Windows without special mingw defines. Also it's not type safe, easy to mess up the stack with some wrong % char, and uses a variable-number-of-parameters hack which breaks down for std::string so a dummy '0' argument is inserted with a macro (the `real_strprintf` etc...).     Many reasons to get rid of the sprintf hacks. But boost::format would be better in that regard as it mostly keeps printf syntax but is typesafe and has none of those mentioned drawbacks.    I don't think the actual risk is that large, at most some debug messages will be formatted differently.    It could map pretty much one-on-one. Could we do this without adding (so many) lines?
3271	28887312	2013-11-20T13:04:55Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28887312	brandondahler	laanwj	@laanwj I would not consider the use of ostringstream as "rolling my own", namely because that is the only way provided by the C++ standard library to convert random types to strings and vice versa.    If you are talking about the Log class, the first commit started off without it, but it was added because it simplifies the actual logging process (the business logic that goes in to putting type T data into X, Y, and Z streams) and it makes reading the actual print lines prettier:        Log() << something << " something else";     vs         LogPrint(str(boost::format("%d something else") % something)); ).
3266	28662216	2013-11-17T19:58:54Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28662216	gmaxwell	kuzetsa	@kuzetsa "nothing invalid about address reuse on a protocol level", well I suggest you review section 10 of Bitcoin PDF, but thats actually not the point I was making here. If I were it would be in the form of "don't allow reuse".    Doubling payments is an actual mistake that people make which could be dampened by a polite confirmation, one which could be disabled with a don't tell me again, that it also provides a hook to _educate_ people about the consequences, both for themselves and for others, is just a bonus. The education matters, considering response I've had to bip32 public chains has been "why does it matter, I know who I'm paying already". :)
3266	28666555	2013-11-17T22:47:38Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28666555	kuzetsa	laanwj	@laanwj The off-topic comment about address reuse really threw me off as a "red herring", and I hadn't even double checked that the actual text of issue #3266 was completely unrelated to any current political movement to stigmatize address reuse, and that instead, you were merely joking about having ulterior motives for wanting to implement this feature, or something related.    @gmaxwell     Yeah, the section 10 is the one labeled "privacy", and since section 10 relates to privacy, rather than the technical details associated with protocol, it's pretty clear that any talk about limiting or avoiding address reuse is only meant as a privacy-enhancing "firewall".    > As an additional firewall, a new key pair should be used (...) if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner.    Address reuse itself has multiple "emergent behavior" type uses which are valid under bitcoin's original whitepaper specifications, as well as any implementation which isn't seeking to manipulate, control, or punish bitcoin users for how they choose to use bitcoin.    Just because some people wish to use bitcoin in a way which reuses addresses, it is not fair to call it a violation of protocol, if only because the word "should" is not the same as "must".    These terms have a meaningful technical distinction, as well as a legal one.    With respect to the actual text of issue #3266 --- I'll concede that if this feature explicitly takes the form of a sanity check to prevent double spends, it'd actually be a positive.
3266	28666555	2013-11-17T22:47:38Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28666555	kuzetsa	gmaxwell	@laanwj The off-topic comment about address reuse really threw me off as a "red herring", and I hadn't even double checked that the actual text of issue #3266 was completely unrelated to any current political movement to stigmatize address reuse, and that instead, you were merely joking about having ulterior motives for wanting to implement this feature, or something related.    @gmaxwell     Yeah, the section 10 is the one labeled "privacy", and since section 10 relates to privacy, rather than the technical details associated with protocol, it's pretty clear that any talk about limiting or avoiding address reuse is only meant as a privacy-enhancing "firewall".    > As an additional firewall, a new key pair should be used (...) if the owner of a key is revealed, linking could reveal other transactions that belonged to the same owner.    Address reuse itself has multiple "emergent behavior" type uses which are valid under bitcoin's original whitepaper specifications, as well as any implementation which isn't seeking to manipulate, control, or punish bitcoin users for how they choose to use bitcoin.    Just because some people wish to use bitcoin in a way which reuses addresses, it is not fair to call it a violation of protocol, if only because the word "should" is not the same as "must".    These terms have a meaningful technical distinction, as well as a legal one.    With respect to the actual text of issue #3266 --- I'll concede that if this feature explicitly takes the form of a sanity check to prevent double spends, it'd actually be a positive.
3266	28678370	2013-11-18T06:49:20Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28678370	laanwj	kuzetsa	@kuzetsa Sigh, it was just a silly statement because of the recent upheaval about privacy and blacklisting, I didn't intend to bring politics discussion here, sorry man.    My message should instead have been: "@gmaxwell good idea", consider it corrected.
3265	28895900	2013-11-20T15:02:44Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28895900	Diapolo	laanwj	@laanwj Agreed, will rework this.
3256	29043042	2013-11-22T01:49:59Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29043042	imton	gmaxwell	@gmaxwell still, why couldn't the option exist?
3254	28515712	2013-11-14T19:42:08Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28515712	Diapolo	laanwj	@laanwj Any idea what is causing this build error, I don't understand the problem.    Edit: Was caused by paymentservertest.cpp, because Gavin called eventFilter() directly, which isn't possible anymore after this pull.
3254	28895984	2013-11-20T15:03:40Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28895984	Diapolo	laanwj	@laanwj Merge-ready or anything more to be done here?
3249	28479591	2013-11-14T12:20:43Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28479591	jgarzik	laanwj	Given all the problems with existing floating point implementations, and existing JSON implementations, and how use of floating point has already lead to incorrect values following a multiplication or division etc. I have always supported the use of satoshis -- all integer -- in the RPC interface.    However, given that that decision was made years ago, backwards compat makes it difficult to switch now.  Even a "use-satoshis" option is not without danger, as @laanwj indicates.   I do not think it is a large danger, because an error would likely result in **sending too little** rather than sending too much.  But it is still a danger.
3249	28480535	2013-11-14T12:38:00Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28480535	laanwj	jgarzik	@jgarzik That's a completely different discussion. JSON always represents numbers as doubles (well that's not strictly true I should say *almost all implementations do*). Moving the decimal point around does not solve that.     But I'd be all for "send coin amounts as strings instead of numbers" option, so that people may be less tempted to use floating point for monetary values with all the risk it entails. This would also be pretty harmless if misconfigured (result in parse errors not incorrect amounts).
3249	28973914	2013-11-21T10:47:34Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28973914	luke-jr	laanwj	@laanwj bitcoind doesn't use double for monetary amounts internally at all... not sure what you mean by that?
3249	28974239	2013-11-21T10:53:15Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28974239	laanwj	luke-jr	@luke-jr We're talking about users of the API here, not so much bitcoind itself.
3249	29042362	2013-11-22T01:34:17Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29042362	super3	imton	@imton What language are you using?
3249	29042923	2013-11-22T01:47:04Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29042923	imton	super3	@super3 I am using RoR, and I took all measures to handle them safely, using RubyMoney/money & money-rails gem.    Still, It will be better if I didn't even have to convert them back from float to handle satoshis as int, as I do in ruby money.
3249	29046733	2013-11-22T03:38:51Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29046733	laanwj	imton	@imton The point is there is nothing *safer* in returning large values instead of smaller, up-to-8-digit precision JSON values. The problem is that javascript (which is at the base of JSON), as well as many other implementations, use doubles for number representation. Double is a *floating point* format, which means that the mantissa has a limited precision, not the number of decimals after the dot.    Sure, you can patch your JSON RPC parser to use integers instead, or maybe yours does already, but if you are going to patch your JSON RPC parser you can do it just as well in the current situation: make it return a Decimal or fixed point format for numbers.    Btw @luke-jr, what you say is not entirely correct, we indeed use uint64 as internal format but we do use doubles in the intermediate conversion for JSON RPC, see         int64_t AmountFromValue(const Value& value)      {          double dAmount = value.get_real();          if (dAmount <= 0.0 || dAmount > 21000000.0)              throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount");          int64_t nAmount = roundint64(dAmount * COIN);          if (!MoneyRange(nAmount))              throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount");          return nAmount;      }        Value ValueFromAmount(int64_t amount)      {          return (double)amount / (double)COIN;      }    This has caused an issue at least once with an upgrade of json::spirit. https://github.com/bitcoin/bitcoin/issues/3126 which somehow formatted numbers differently.    *When we'd use strings we could avoid converting to double intermediate format at all and be fixed-point all the way to the client.*
3249	29046733	2013-11-22T03:38:51Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29046733	laanwj	luke-jr,	@imton The point is there is nothing *safer* in returning large values instead of smaller, up-to-8-digit precision JSON values. The problem is that javascript (which is at the base of JSON), as well as many other implementations, use doubles for number representation. Double is a *floating point* format, which means that the mantissa has a limited precision, not the number of decimals after the dot.    Sure, you can patch your JSON RPC parser to use integers instead, or maybe yours does already, but if you are going to patch your JSON RPC parser you can do it just as well in the current situation: make it return a Decimal or fixed point format for numbers.    Btw @luke-jr, what you say is not entirely correct, we indeed use uint64 as internal format but we do use doubles in the intermediate conversion for JSON RPC, see         int64_t AmountFromValue(const Value& value)      {          double dAmount = value.get_real();          if (dAmount <= 0.0 || dAmount > 21000000.0)              throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount");          int64_t nAmount = roundint64(dAmount * COIN);          if (!MoneyRange(nAmount))              throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount");          return nAmount;      }        Value ValueFromAmount(int64_t amount)      {          return (double)amount / (double)COIN;      }    This has caused an issue at least once with an upgrade of json::spirit. https://github.com/bitcoin/bitcoin/issues/3126 which somehow formatted numbers differently.    *When we'd use strings we could avoid converting to double intermediate format at all and be fixed-point all the way to the client.*
3239	28261988	2013-11-12T02:05:31Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28261988	jgarzik	luke-jr	@luke-jr getblocktemplate always produces a subset of mempool
3239	28262901	2013-11-12T02:27:33Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28262901	jgarzik	luke-jr	@luke-jr Yes, always.  Sometimes subset == set, but usually not.  The mempool will always store more than **one** block's worth of transactions.  getblocktemplate only returns up to 1MB, etc.
3239	28864476	2013-11-20T05:19:20Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28864476	gavinandresen	laanwj	@laanwj: good catch, using ValueFromAmount to report fees now.
3229	28233487	2013-11-11T20:02:01Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28233487	luke-jr	laanwj	@laanwj That'd need making the variables globals again.. so maybe this is better after all?
3228	28144873	2013-11-10T06:06:11Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28144873	fanquake	gthiruva	@gthiruva Which version of Boost are you using, 1.54.0 ?
3228	28434383	2013-11-13T21:14:00Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28434383	gthiruva	fanquake	@fanquake Yep, 1.50.0 from macports:  ```shell  The following ports are currently installed:    boost @1.54.0_0+no_single+no_static+python27 (active)  ```  @laanwj And, yes. `make clean` and even `make distclean`.
3228	28434383	2013-11-13T21:14:00Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28434383	gthiruva	1.54.0_0+no_single+no_static+python27	@fanquake Yep, 1.50.0 from macports:  ```shell  The following ports are currently installed:    boost @1.54.0_0+no_single+no_static+python27 (active)  ```  @laanwj And, yes. `make clean` and even `make distclean`.
3228	28434383	2013-11-13T21:14:00Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28434383	gthiruva	laanwj	@fanquake Yep, 1.50.0 from macports:  ```shell  The following ports are currently installed:    boost @1.54.0_0+no_single+no_static+python27 (active)  ```  @laanwj And, yes. `make clean` and even `make distclean`.
3226	28389079	2013-11-13T12:00:10Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28389079	laanwj	gmaxwell	At least initially I'm fine with centralized rendezvous servers. Sure, a standardized P2P protocol would be better (and very difficult) but one step at a time. As @gmaxwell describes in the mentioned topic, the server can learn only very little. It's never worse than the current state in terms of privacy.    Deterministic wallets and such provide no extra privacy in the block chain if you're already keeping to the privacy guidelines and using a new address for every transaction.
3226	28591058	2013-11-15T18:18:48Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28591058	Diapolo	petertodd	@petertodd Isn't there some double-spend detecion pull lingering around here?
3226	28591517	2013-11-15T18:25:00Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28591517	petertodd	Diapolo	@Diapolo There is, but unfortunately it only handles the case of a double-spend of a transaction sent to you; it doesn't handle double-spends of transactions that you send.    Specifically: http://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03126.html
3226	28664276	2013-11-17T21:20:48Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28664276	petertodd	mikehearn	@mikehearn You need to be able to handle a coinjoin participate maliciously double-spending their input.    @simondlr CoinJoin definitely needs to be a "by default" action in the long run for all payments to get the maximum benefit; I outlined this on the -talk forum: https://bitcointalk.org/index.php?topic=334241.msg3615921#msg3615921    In the short term there are issues with services that make bad assumptions about address re-use. It's nice that the payment protocol is so clear that txin's aren't return addresses; CoinJoin can easily be made the default way to send payments there provided a good implementation exists.    My thinking on that implementation is you really want to focus on making the default user experience seamless, and I think that means a simple, two-party mix protocol with a reasonably low default timeout. In the default case, it's ok if the transaction doesn't always wind up being joined. Equally, we may be able to take advantage of a fee UI's - if user's are taking advantage of time/cost trade-offs anyway integrate that configurable timeout as part of the CoinJoin process, which in turn helps the users who want a transaction sent quicker.
3226	28664276	2013-11-17T21:20:48Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28664276	petertodd	simondlr	@mikehearn You need to be able to handle a coinjoin participate maliciously double-spending their input.    @simondlr CoinJoin definitely needs to be a "by default" action in the long run for all payments to get the maximum benefit; I outlined this on the -talk forum: https://bitcointalk.org/index.php?topic=334241.msg3615921#msg3615921    In the short term there are issues with services that make bad assumptions about address re-use. It's nice that the payment protocol is so clear that txin's aren't return addresses; CoinJoin can easily be made the default way to send payments there provided a good implementation exists.    My thinking on that implementation is you really want to focus on making the default user experience seamless, and I think that means a simple, two-party mix protocol with a reasonably low default timeout. In the default case, it's ok if the transaction doesn't always wind up being joined. Equally, we may be able to take advantage of a fee UI's - if user's are taking advantage of time/cost trade-offs anyway integrate that configurable timeout as part of the CoinJoin process, which in turn helps the users who want a transaction sent quicker.
3226	28687946	2013-11-18T10:33:38Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28687946	idiotsabound	mikehearn	Can someone tell @mikehearn to give up with the whole "let's give bitcoin taints and blacklists and (add on all manner of ridiculous things here)"?(?)  Folks, please get on the coinjoin train.  Big ups to @luke-jr (et. al.) for the P2P concept.  Get er done.  Moving on.  Now, for those who are still attached to the state... Detach.  Thank you, and goodnight.
3226	28687946	2013-11-18T10:33:38Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28687946	idiotsabound	luke-jr	Can someone tell @mikehearn to give up with the whole "let's give bitcoin taints and blacklists and (add on all manner of ridiculous things here)"?(?)  Folks, please get on the coinjoin train.  Big ups to @luke-jr (et. al.) for the P2P concept.  Get er done.  Moving on.  Now, for those who are still attached to the state... Detach.  Thank you, and goodnight.
3226	28692378	2013-11-18T11:53:00Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28692378	laanwj	idiotsabound	@idiotsabound if you're not helping development, please don't distract us here
252	3200366	2011-12-19T08:09:55Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3200366	stuhood	laanwj	@laanwj It's not... sorry! Got caught up in other obligations.
242	2507653	2011-10-24T18:53:59Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2507653	freewil	DataSurfer	@DataSurfer: try upgrading your client and you shall find what you're looking for :)    https://en.bitcoin.it/w/index.php?title=Original_Bitcoin_client/API_calls_list
232	1364980	2011-06-14T10:04:41Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1364980	TheBlueMatt	sysfrog	@sysfrog Im not sure.  Though it may claim to be more secure, 1000 rounds on OpenSSL's algorithm is also very secure and I think I'd rather use a more common/well used/well analysed algorithm like OpenSSL's entire code base is.
232	1364981	2011-06-14T10:05:12Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1364981	TheBlueMatt	dizzyd	@dizzyd Ill take a look at updating to your other recommendations when I have a chance.
232	1382673	2011-06-16T17:13:56Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1382673	gstarnberger	TheBlueMatt	@TheBlueMatt As far as I understand scrypt the main advantage over older techniques is that it not only adds computational complexity to calculate a given key from a password, but that each calculation also requires a given amount of RAM. So it's much harder to parallelize an attack with, e.g., an ASIC, as you would need lots of RAM to do so.    But I agree with you: There have been much more reviews of the SSL code base, and so the chance of critical errors in OpenSSL is much lower compared to scrypt.
232	1382749	2011-06-16T17:24:32Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1382749	TheBlueMatt	witkamp	@witkamp mostly because it would be a pain to store.  This patch already uses the public key as the IV for the encryption of each private key so any kind of brute force/dictionary attack is already ridiculously difficult, I dont see a major advantage to adding a random salt to be used for a given wallet (and then stored in the wallet) as to brute force a wallet, you already need to know some of the information in the wallet (namely the public keys).  But maybe others disagree?    @sysfrog OK, so its agreed then that OpenSSL key derivation is probably the best way to go?    @dizzyd Still planning on updating with some of your original recommendations, but I'm on vacation atm and dont feel like doing much coding.
232	1382749	2011-06-16T17:24:32Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1382749	TheBlueMatt	sysfrog	@witkamp mostly because it would be a pain to store.  This patch already uses the public key as the IV for the encryption of each private key so any kind of brute force/dictionary attack is already ridiculously difficult, I dont see a major advantage to adding a random salt to be used for a given wallet (and then stored in the wallet) as to brute force a wallet, you already need to know some of the information in the wallet (namely the public keys).  But maybe others disagree?    @sysfrog OK, so its agreed then that OpenSSL key derivation is probably the best way to go?    @dizzyd Still planning on updating with some of your original recommendations, but I'm on vacation atm and dont feel like doing much coding.
232	1382749	2011-06-16T17:24:32Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1382749	TheBlueMatt	dizzyd	@witkamp mostly because it would be a pain to store.  This patch already uses the public key as the IV for the encryption of each private key so any kind of brute force/dictionary attack is already ridiculously difficult, I dont see a major advantage to adding a random salt to be used for a given wallet (and then stored in the wallet) as to brute force a wallet, you already need to know some of the information in the wallet (namely the public keys).  But maybe others disagree?    @sysfrog OK, so its agreed then that OpenSSL key derivation is probably the best way to go?    @dizzyd Still planning on updating with some of your original recommendations, but I'm on vacation atm and dont feel like doing much coding.
232	1382789	2011-06-16T17:30:53Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1382789	enmaku	TheBlueMatt	@TheBlueMatt gotcha, didn't see the public key = IV bit but it makes sense and stops dictionary/BF attacks at least as well as a random salt so I'm happy with it as a solution.
232	1383776	2011-06-16T19:49:29Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1383776	dizzyd	dizzyd	On Thu, Jun 16, 2011 at 11:24 AM, TheBlueMatt < reply@reply.github.com>wrote:  > > @dizzyd Still planning on updating with some of your original > recommendations, but I'm on vacation atm and dont feel like doing much > coding. >  No worries -- I read your last reply first and was confused. :)  D.
232	1407446	2011-06-21T02:09:36Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407446	mutantmonkey	phantomcircuit	@phantomcircuit That attack is effective against 11-round AES-256, but not full 14-round AES-256. It'd be better to increase the number of rounds (he recommends 28 or more in that article) used instead of using a smaller key size. There are plenty of attacks on AES-128 as well, many of which were published after that article was written.
220	1590491	2011-07-17T16:15:02Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1590491	sipa	lachesis	@lachesis: should be fixed
220	2150228	2011-09-20T21:46:15Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2150228	casascius	gmaxwell	@gmaxwell: What part of this functionality constitutes an exploit?  The idea that one should be able to have their own private keys on paper, or on bitbills, or on physical bitcoins, etc. should be something that enhances security, not detracts from it.  Please explain how security is compromised.
220	2160082	2011-09-21T19:40:18Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2160082	enmaku	sipa	@sipa: Nice mod!  @gavinandresen re: testing: Works beautifully on Debian squeeze i686. All added functionality tested and working properly.  @casascius: +1 for adding Mini Private Key format. It should be pretty easy to implement. Also, I believe the problem @gmaxwell was addressing is that scammers can generate "secure" keypairs for their victims and then never relinquish control of the private key, thus allowing them to steal funds from those accounts later
220	2160082	2011-09-21T19:40:18Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2160082	enmaku	gavinandresen	@sipa: Nice mod!  @gavinandresen re: testing: Works beautifully on Debian squeeze i686. All added functionality tested and working properly.  @casascius: +1 for adding Mini Private Key format. It should be pretty easy to implement. Also, I believe the problem @gmaxwell was addressing is that scammers can generate "secure" keypairs for their victims and then never relinquish control of the private key, thus allowing them to steal funds from those accounts later
220	2160082	2011-09-21T19:40:18Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2160082	enmaku	casascius	@sipa: Nice mod!  @gavinandresen re: testing: Works beautifully on Debian squeeze i686. All added functionality tested and working properly.  @casascius: +1 for adding Mini Private Key format. It should be pretty easy to implement. Also, I believe the problem @gmaxwell was addressing is that scammers can generate "secure" keypairs for their victims and then never relinquish control of the private key, thus allowing them to steal funds from those accounts later
220	2160082	2011-09-21T19:40:18Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2160082	enmaku	gmaxwell	@sipa: Nice mod!  @gavinandresen re: testing: Works beautifully on Debian squeeze i686. All added functionality tested and working properly.  @casascius: +1 for adding Mini Private Key format. It should be pretty easy to implement. Also, I believe the problem @gmaxwell was addressing is that scammers can generate "secure" keypairs for their victims and then never relinquish control of the private key, thus allowing them to steal funds from those accounts later
220	2160269	2011-09-21T19:56:38Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2160269	casascius	enmaku,gmaxwell	@enmaku,@gmaxwell: I wasn't sure if keeping the private key was the concern here, because bitaddress.org appears to have been created with that concern in mind.  The generator at bitaddress.org is actually quite novel from a security perspective: the generation is entirely client-side and implemented in javascript in easy-to-read code in a single self-contained html file that contains no references to any network resources.  The QR codes are generated from scratch, client-side, as well.  This is exactly how a personal address generator should be.  One can save the single .html file to disk and use it to safely generate bitcoin addresses straight to their printer while disconnected from the internet.  To me, it's a shining example of a good idea rather than an exploit.
220	2160324	2011-09-21T20:00:46Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2160324	enmaku	casascius	@casascius: I think the concern is that while you and I might check the source, 99% of folks won't and eventually one will crop up that phones home and makes a big database of privkeys ripe for exploitation. Realistically though this isn't our problem any more than any other product or service whose userbase is regularly phished. We can put the info out there, but people want this feature and if it's not in the main client it'll be in external tools like pywallet. We can't stop those who want to from importing addresses, merging wallets, etc. The best we can do is put up big scary popups in the GUI implementation informing folks that messing with the wallet is dangerous and if they do stupid things they'll get bad results.
220	2160427	2011-09-21T20:10:07Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2160427	casascius	enmaku	@enmaku: I share the concern, and am appreciative of the fact that the author of this website makes no attempt to explain what his website does to newbies.  You have to know why you're there and what the number means, otherwise it is just a gibberish generator.  And the part I appreciate the most is simply that he has released functional code that can be clipped and put into other environments where the source is ostensibly trusted. (e.g. on MtGox, or on the LinuxCoin ISO).  Free bonus is it's platform independent.    I think the best thing that can be done to the GUI implementation would be to include this functionality where the user can get at it, and seek to be less user unfriendly, then websites like this wouldn't have a reason to exist.
220	2183844	2011-09-23T23:27:42Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2183844	sipa	casascius'	What do other people think about support for @casascius' mini private keys?
220	2184519	2011-09-24T02:02:28Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2184519	casascius	sipa	@sipa: Do you suggest that a 56-character private key format that uses only uppercase be implemented instead of, versus in addition to, the 22 character format I propose?  You make a very good point, in that with such a scheme, a smaller QR code becomes possible without any question as to whether a reduction is lessening security.    My physical bitcoins aside, I believe a short-to-type private key format is highly valuable and important to Bitcoin's future.  I foresee Joe Sixpack buying bitcoins for cash at a pawn shop or check cashing place, and him receiving them in the form of a pre-made scratch-off card that gets activated (read: loaded) at the register.  Which he will then take to the Bitcoin-accepting online marketplace of his choice, and type it in for instant credit.  He may or may not be able to scan a QR code, and this Joe won't be downloading clients or block chains.  Typing 50+ mixed-case characters really sucks (done it numerous times), but especially for Joe.  Even 22 sucks, but that's already flirting with the minimum enough and there is not much that can be done about that.
220	2184564	2011-09-24T02:19:12Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2184564	casascius	sipa	@sipa:  If you calculated half of all the minikeys and ignored all the ones that needed 717 rounds to generate, you'd only victimize those who elected to use the ones that passed on the first round.  Those who follow the best practice of only using only the ones that pass on round 717, and not on round 1, where able, are not going to be affected.  On the other hand, if you're a javascript and you need to quickly generate an address to collect a payment that's going to get swept to another wallet right away anyway, the option for a 1 round key comes in handy.    Supporting the import of these private keys in the client doesn't in and of itself encourage their unnecessary use.  The average joe user isn't going to be making the decision as to which kind of key to use, these decisions are presumably going to be made by developers who would have the intellectual means to weigh whether generating minikeys versus full keys in their app is a good design decision.  I think it would be irresponsible to put a "generate minikey" button in the client.  But I don't think it serves any useful purpose to not accept them as imports and instead demand the user use some other utility to get the job he already needs done, done.  (Having him find and download the other utility exposes him to a new class of risks by itself, far more frightening than a brute force attack on the key space).
220	2184680	2011-09-24T03:00:41Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2184680	casascius	gmaxwell	@gmaxwell: I used the "either or" check so that there would be a means to generate a crappy key if you only need it for a short time for a crappy purpose.  In other words, if you have the means to select a key that passes the 717 check and not the 1st check, then by all means do that.  That means, to generate a "better" key, explicitly discard all the candidates that pass on the 1st check.    I agree with you that javascript is a poor environment to be generating keys, and I mention it only for ease of illustration.  Minikeys could be needed in the context of an interpreted language on a server, or on a microcontroller.  Imagine a check cashing shop that sells BTC and uses a VeriFone point-of-sale credit card machine to generate and issue a minicode on a piece of receipt tape - a very plausible application.  That little box with its 400 MHz underclocked ARM and 2MB memory might not be able to do 180000 SHA256's in any short order, and 95% says the dude buying it is probably going to redeem it that same day, so the window of opportunity for a thief is vanishingly short.    On the other hand, let's kick around as granted the conclusion that this is a bad idea.  What do we want Joe Sixpack to do instead when he acquires a private key given to him on paper?  We could make him type 51 characters instead of 22, sure.  We could make him type 26 or 30 as well.  We could make him scan a QR code, but it's likely he either has nothing to scan it with, or is almost certainly going to have to hand-key it off his cell phone and into his computer, making the QR code of no benefit and nothing more than an extra burdensome step.  I suppose it's fair to say that a minimum length keycode is universally desirable, and it's really just where to draw the line of being reckless with security.    Let me also propose an alternate solution.  The key space for my proposal is all of those who pass the SHA256 check with the magic byte "00".  What if, in addition to this, we define another key space, and that's all of those 22-character base58 codes who fail my check but pass with magic byte "01".  And then we utilize a far more computationally intensive key derivation function to compute the 32-bytes in place of SHA256, that dwarfs both SHA256 and EC in resource complexity, and define that as the best practice for generating such short keycodes.  And then still leave 717 and even 1-round SHA256 as a weak option so that microcontrollers can still stay in the game where needed.
220	2690578	2011-11-10T02:01:32Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2690578	T-X	sipa	@sipa: "What do other people think about support for @casascius' mini private keys?"    Sounds like an extra feature which will need extra attention. Maybe it should be added as an additional commit on top later and should be further discussed under a separate pull request after the "straightforward" 51-character base58-encoded import/export version got added?
220	2690578	2011-11-10T02:01:32Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2690578	T-X	casascius'	@sipa: "What do other people think about support for @casascius' mini private keys?"    Sounds like an extra feature which will need extra attention. Maybe it should be added as an additional commit on top later and should be further discussed under a separate pull request after the "straightforward" 51-character base58-encoded import/export version got added?
218	15325538	2013-03-22T22:56:31Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/15325538	gavinandresen	mai77	@mai77 : does your commercial bank really let you send money anywhere in the world for less than 3 cent  ?
218	15327802	2013-03-23T00:24:23Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/15327802	mai77	Gavin	If the fee is too high, which it is, bitcoin cannot be a micro payment system anymore. The fee should just disincentivize spammers.   @Gavin: I get SEPA for free, even the mTAN SMS is on the bank. If btc exchange rate is rising further, 0.0005 btc is too dear.
216	4091361	2012-02-21T23:00:50Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/4091361	sipa	laanwj	@laanwj Does this problem still exist?
214	1491134	2011-07-03T01:32:21Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1491134	jgarzik	JoelKatz	@JoelKatz:  you missed the point.  This is not an optimization, but a big step towards correcting a major design flaw.  The current RPC code executes HTTP requests in order, in a FIFO queue.    You can find examples of this logic in "My First TCP Server" style code examples, but never in any production server.  A synchronous, FIFO approach stalls all clients except the "current" one.  If the current client is, itself, stalled or slow or misbehaving, then all other clients suffer.    Asynchronous I/O + HTTP/1.1 keep alives are desperately needed to solve obvious problems seen in the field by heavy RPC users.
209	3290333	2011-12-28T12:20:20Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3290333	laanwj	midnightmagic	@midnightmagic: But if the host is remote/tunneled, wouldn't it make sense to use a fully qualified path in the first place?    I think, in general, with this API you always want to send a fully qualified path to make sure the backup ends up in the right place.     Maybe the API should be similarly changed to reject non-fully qualified paths, to prevent (extremely sensitive) backups from being written to places the user doesn't expect them.
209	5586301	2012-05-08T21:02:01Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/5586301	jgarzik	sipa	Closing.  Please either    1) Update code to require full pathname, or    2) Update code to send entire wallet via RPC, which @sipa admits is a mostly-rewrite
199	1458399	2011-06-28T19:40:12Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1458399	cdhowie	pixelglow	@pixelglow: I had that in at some point and Gavin asked that I remove it.  :)  But it's a one line change to add it.    The transactions should be listed sorted by block.  So in terms of the time that the blocks were created, you can infer that from the time the transaction happened.  If all you care about is which blocks came before which blocks, then you don't even have to look at the transaction times, just their order.
199	1471413	2011-06-29T23:20:56Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1471413	pixelglow	cdhowie	@cdhowie that is an excellent idea and solves exactly the issue I have with confirmations. I can't see any other reason why someone would need to look at earlier blocks than the last, other than checking confirmations. (But then again, I'm a newbie when it comes to bitcoin :-) ).
180	1124735	2011-05-09T16:53:49Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1124735	jgarzik	Gavin	NAK the mingw stuff from Matt -- it is absolutely not needed.  That stuff varies from system to system, and hardcoding it into configure _breaks_ platforms other than the one Matt's using.    @Gavin:  can do
180	1124803	2011-05-09T17:06:09Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1124803	TheBlueMatt	jgarzik	@jgarzik Isnt that the point of autotools, it finds the stuff to include and link and uses that.  As I said, the stuff in this pull request from my repo really should never be pulled (because of what you just said)
180	1126416	2011-05-09T21:23:27Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1126416	TheBlueMatt	jaromil	@jaromil Your commit was merged. https://github.com/bitcoin/bitcoin/commit/84c3fb07b0b8199c7f85c5de280e7100bad0786f is your commit in the repo.  Its the same pull methods used in every other pull, the merge shows up as done by jgarzik, but your commit is back in the repo by its original date.
180	1448987	2011-06-27T17:33:01Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1448987	jrmithdobbs	2.68	OSX Broken? (10.6.7 xcode 4):    mith@dair:0:~/src/bitcoin$ port list autoconf automake miniupnpc boost wxWidgets-devel  autoconf                       @2.68           devel/autoconf  automake                       @1.11.1         devel/automake  miniupnpc                      @1.5            net/miniupnpc  boost                          @1.46.1         devel/boost  wxWidgets-devel                @2.9.1          graphics/wxWidgets-devel  mith@dair:0:~/src/bitcoin$ autoconf  configure.ac:124: error: possibly undefined macro: AM_INIT_AUTOMAKE        If this token and others are legitimate, please use m4_pattern_allow.        See the Autoconf documentation.  configure.ac:140: error: possibly undefined macro: AM_PROG_AS  configure.ac:229: error: possibly undefined macro: AM_OPTIONS_WXCONFIG  configure.ac:230: error: possibly undefined macro: AM_PATH_WXCONFIG  configure.ac:261: error: possibly undefined macro: AM_CONDITIONAL  mith@dair:1:~/src/bitcoin$ ./configure --prefix=/usr/local  configure: error: cannot find install-sh, install.sh, or shtool in "." "./.." "./../.."
180	1448987	2011-06-27T17:33:01Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1448987	jrmithdobbs	1.11.1	OSX Broken? (10.6.7 xcode 4):    mith@dair:0:~/src/bitcoin$ port list autoconf automake miniupnpc boost wxWidgets-devel  autoconf                       @2.68           devel/autoconf  automake                       @1.11.1         devel/automake  miniupnpc                      @1.5            net/miniupnpc  boost                          @1.46.1         devel/boost  wxWidgets-devel                @2.9.1          graphics/wxWidgets-devel  mith@dair:0:~/src/bitcoin$ autoconf  configure.ac:124: error: possibly undefined macro: AM_INIT_AUTOMAKE        If this token and others are legitimate, please use m4_pattern_allow.        See the Autoconf documentation.  configure.ac:140: error: possibly undefined macro: AM_PROG_AS  configure.ac:229: error: possibly undefined macro: AM_OPTIONS_WXCONFIG  configure.ac:230: error: possibly undefined macro: AM_PATH_WXCONFIG  configure.ac:261: error: possibly undefined macro: AM_CONDITIONAL  mith@dair:1:~/src/bitcoin$ ./configure --prefix=/usr/local  configure: error: cannot find install-sh, install.sh, or shtool in "." "./.." "./../.."
180	1448987	2011-06-27T17:33:01Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1448987	jrmithdobbs	1.5	OSX Broken? (10.6.7 xcode 4):    mith@dair:0:~/src/bitcoin$ port list autoconf automake miniupnpc boost wxWidgets-devel  autoconf                       @2.68           devel/autoconf  automake                       @1.11.1         devel/automake  miniupnpc                      @1.5            net/miniupnpc  boost                          @1.46.1         devel/boost  wxWidgets-devel                @2.9.1          graphics/wxWidgets-devel  mith@dair:0:~/src/bitcoin$ autoconf  configure.ac:124: error: possibly undefined macro: AM_INIT_AUTOMAKE        If this token and others are legitimate, please use m4_pattern_allow.        See the Autoconf documentation.  configure.ac:140: error: possibly undefined macro: AM_PROG_AS  configure.ac:229: error: possibly undefined macro: AM_OPTIONS_WXCONFIG  configure.ac:230: error: possibly undefined macro: AM_PATH_WXCONFIG  configure.ac:261: error: possibly undefined macro: AM_CONDITIONAL  mith@dair:1:~/src/bitcoin$ ./configure --prefix=/usr/local  configure: error: cannot find install-sh, install.sh, or shtool in "." "./.." "./../.."
180	1448987	2011-06-27T17:33:01Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1448987	jrmithdobbs	1.46.1	OSX Broken? (10.6.7 xcode 4):    mith@dair:0:~/src/bitcoin$ port list autoconf automake miniupnpc boost wxWidgets-devel  autoconf                       @2.68           devel/autoconf  automake                       @1.11.1         devel/automake  miniupnpc                      @1.5            net/miniupnpc  boost                          @1.46.1         devel/boost  wxWidgets-devel                @2.9.1          graphics/wxWidgets-devel  mith@dair:0:~/src/bitcoin$ autoconf  configure.ac:124: error: possibly undefined macro: AM_INIT_AUTOMAKE        If this token and others are legitimate, please use m4_pattern_allow.        See the Autoconf documentation.  configure.ac:140: error: possibly undefined macro: AM_PROG_AS  configure.ac:229: error: possibly undefined macro: AM_OPTIONS_WXCONFIG  configure.ac:230: error: possibly undefined macro: AM_PATH_WXCONFIG  configure.ac:261: error: possibly undefined macro: AM_CONDITIONAL  mith@dair:1:~/src/bitcoin$ ./configure --prefix=/usr/local  configure: error: cannot find install-sh, install.sh, or shtool in "." "./.." "./../.."
180	1448987	2011-06-27T17:33:01Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1448987	jrmithdobbs	2.9.1	OSX Broken? (10.6.7 xcode 4):    mith@dair:0:~/src/bitcoin$ port list autoconf automake miniupnpc boost wxWidgets-devel  autoconf                       @2.68           devel/autoconf  automake                       @1.11.1         devel/automake  miniupnpc                      @1.5            net/miniupnpc  boost                          @1.46.1         devel/boost  wxWidgets-devel                @2.9.1          graphics/wxWidgets-devel  mith@dair:0:~/src/bitcoin$ autoconf  configure.ac:124: error: possibly undefined macro: AM_INIT_AUTOMAKE        If this token and others are legitimate, please use m4_pattern_allow.        See the Autoconf documentation.  configure.ac:140: error: possibly undefined macro: AM_PROG_AS  configure.ac:229: error: possibly undefined macro: AM_OPTIONS_WXCONFIG  configure.ac:230: error: possibly undefined macro: AM_PATH_WXCONFIG  configure.ac:261: error: possibly undefined macro: AM_CONDITIONAL  mith@dair:1:~/src/bitcoin$ ./configure --prefix=/usr/local  configure: error: cannot find install-sh, install.sh, or shtool in "." "./.." "./../.."
180	1450406	2011-06-27T21:00:09Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1450406	jgarzik	jrmithdobbs	@jrmithdobbs:  that last is standard.  you want AM_MAINTAINER_MODE + "make maintainer-clean" (or "make maintainerclean", I forget)    "distclean" is only supposed to return you to the state of a freshly-unpacked dist tarball
100	2369722	2011-10-11T19:02:10Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2369722	laanwj	WakiMiko	As @WakiMiko mentions, this was merged with the Qt UI, closing the issue
68	1248127	2011-05-27T09:26:50Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1248127	sipa	alexgenaud	@alexgenaud: the wallet is much more than a collection of keys - it also contains transactions, accounting information, settings, and information about the block chain
68	15730620	2013-04-01T18:57:15Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/15730620	gmaxwell	keystrike	@keystrike  it's likely going to get subsumed by the multiple wallet support.
68	17150936	2013-04-29T05:45:14Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/17150936	laanwj	APerson241	Does that mean you're volunteering to do it @APerson241 ? Otherwise, please spare us your judgements as to how easy or difficult something is.
64	4091463	2012-02-21T23:05:00Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/4091463	sipa	laanwj	@laanwj I read compatibility with NVDA was recently added?
14	4091435	2012-02-21T23:03:46Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/4091435	sipa	TheBlueMatt	@TheBlueMatt BIP21 compatible URI's are now supported; can this issue be closed ?
2	17063592	2013-04-26T09:28:41Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/17063592	Diapolo	jgarzik	@jgarzik ACK
