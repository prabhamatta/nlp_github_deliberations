3294	29035854	2013-11-21T23:39:16Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29035854	gavinandresen	@Diapolo: good catch on the -1.  init.cpp doesn't mention gen/genproclimit, since generating blocks is a developer-only feature (we don't want people thinking they can successfully CPU mine on the main network).  
3294	29039395	2013-11-22T00:38:54Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29039395	BitcoinPullTester	Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/c8b74258bad399d39262ed11b892a729196cb297 for binaries and test log. This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/ Contact BlueMatt on freenode if something looks broken.
3294	29069092	2013-11-22T12:31:38Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29069092	sipa	I think overloading the meaning of that setgenerate argument for regtest is ugly.    Can't we move that functionality to an additional argument? Ideally there are as few explicit checks for what network we're working on in the code itself.
3294	29119945	2013-11-23T00:17:58Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29119945	gavinandresen	@sipa: number of threads is ignored in regtest mode already (one thread is used, and it exits as soon as a block is found).    If you like, you can think of it as "Start N threads, and exit each as soon as a block is found."  That isn't actually how it is implemented, of course (blocks are found so quickly the N threads would stomp on each other's blocks)...    I'm normally sympathetic to "makes RPC ugly" arguments, but since setgenerate is ONLY for developers/testing/debugging I think ugly is just fine here.
3294	29127173	2013-11-23T06:42:37Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29127173	laanwj	Right, I was about to make the same comment about overloading arguments when I saw the code, another thing that I noticed is that setgenerate (regtest) and setgenerate (normal) are almost completely distinct and it may make sense to split functions instead of check the mode everywhere.    ...but it's only setgenerate so meh.
3293	28949144	2013-11-21T01:02:11Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28949144	BitcoinPullTester	Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/ef1e984eade3166f807197eccba378fa937b6f88 for binaries and test log. This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/ Contact BlueMatt on freenode if something looks broken.
3292	28965361	2013-11-21T08:25:43Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28965361	laanwj	It's too bad that we lost support for Qt5 with the autoconf switch. I would think Qt5 handles this better.
3292	28975951	2013-11-21T11:20:17Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28975951	fanquake	Related reading http://blog.qt.digia.com/blog/2013/04/25/retina-display-support-for-mac-os-ios-and-x11/
3292	28976556	2013-11-21T11:31:16Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28976556	laanwj	Thanks @fanquake 
3292	28999208	2013-11-21T16:30:39Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28999208	Diapolo	Qt5 and up have explicitly better retina or high DPI support AFAIK. We should really switch to Qt5.1 for our release builds and pull tester...
3292	29002309	2013-11-21T17:04:33Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29002309	Diapolo	See #3297
3287	28896993	2013-11-20T15:15:27Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28896993	BitcoinPullTester	Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/67448b245c0931c2bf721389ef7aa5f3933da937 for binaries and test log. This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/ Contact BlueMatt on freenode if something looks broken.
3286	29006854	2013-11-21T17:55:19Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29006854	Diapolo	@laanwj Am I right that MaxAddressLength is not the MinAddressLength ;)? And if this is the case, what is the minimum length of a BTC address? This is not yet mergable in the current state ^^.
3286	29055366	2013-11-22T08:07:23Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29055366	Diapolo	@laanwj Re-worked, can you check for correctness?
3286	29055864	2013-11-22T08:15:28Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29055864	laanwj	Looks ok, but I'm not sure we should really be checking the length of the address at all, as we have much more reliable methods to check the validity of an address.  
3286	29056449	2013-11-22T08:28:19Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29056449	BitcoinPullTester	Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/ea9f6ccf449e359600ada5000858da93e9e772d2 for binaries and test log. This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/ Contact BlueMatt on freenode if something looks broken.
3286	29061281	2013-11-22T09:57:54Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29061281	Diapolo	This is just a pre-check, if that fails why would we check with CBitcoinAddress anyway ;)? The big plus is that too short addresses will already mark the field as invalid, when focusing out, I like that behaviour, try it.
3285	28910487	2013-11-20T17:34:33Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28910487	BitcoinPullTester	Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/9aeaf8c1dbc14f3421c2c5bfc9b3f34e89febd20 for binaries and test log. This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/ Contact BlueMatt on freenode if something looks broken.
3285	29007831	2013-11-21T18:05:50Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29007831	Diapolo	I have more string and translations updates, but don't want to bloat this pull, so it get's merged faster.  @laanwj Can you take a look please?
3284	28965276	2013-11-21T08:24:01Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28965276	BitcoinPullTester	Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/09608542da107c8c060483e1e1f5c2dc62f262bd for binaries and test log. This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/ Contact BlueMatt on freenode if something looks broken.
3284	28979434	2013-11-21T12:20:55Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28979434	laanwj	@sipa @gmaxwell @gavinandresen Can I get some acks here please?  
3284	28983010	2013-11-21T13:11:05Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28983010	sipa	ACK design. The code looks good, but I haven't checked all moves in detail.
3284	29030686	2013-11-21T22:23:28Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29030686	super3	ACK concept. Going to take a bit to read through. 
3282	28892088	2013-11-20T14:16:44Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28892088	laanwj	For Qt I'd expect this to be one of the window flags, but I can't find it http://qt-project.org/doc/qt-4.8/qt.html#WindowType-enum  Maybe the splash screen window type never gets a taskbar entry, in which case you'd have to change the type of window.
3281	28788339	2013-11-19T13:09:03Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28788339	BitcoinPullTester	Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/35f21fdfa76666f0d54c8d4ae4e9c7bef54338d3 for binaries and test log. This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/ Contact BlueMatt on freenode if something looks broken.
3277	28703086	2013-11-18T14:47:34Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28703086	BitcoinPullTester	Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/b4d9db77faf2105a60c0e1f85c2f3dff6901df98 for binaries and test log. This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/ Contact BlueMatt on freenode if something looks broken.
3276	28793347	2013-11-19T14:24:22Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28793347	laanwj	Code changes look good
3276	28943815	2013-11-20T23:34:36Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28943815	sipa	Rebased to trigger pulltester evaluation.
3276	28948690	2013-11-21T00:53:25Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28948690	sipa	I missed the should-not-disconnect-localhost behaviour, thanks pulltester!
3276	28949618	2013-11-21T01:11:31Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28949618	BitcoinPullTester	Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/6a14a6e8b5c52211601258eed258cd05c2e7fd46 for binaries and test log. This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/ Contact BlueMatt on freenode if something looks broken.
3276	29069119	2013-11-22T12:32:02Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29069119	sipa	@gavinandresen @gmaxwell Some ACKs?
3273	28649263	2013-11-17T14:20:12Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28649263	BitcoinPullTester	Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/fb0507fe4b3ff733386c8e3580032cfc965eec17 for binaries and test log. This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/ Contact BlueMatt on freenode if something looks broken.
3273	28983865	2013-11-21T13:23:21Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28983865	Diapolo	ACK to the idea, didn't test the code... but looks sane :).
3271	28642450	2013-11-17T04:36:49Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28642450	jgarzik	While the motivation is appreciated...  meh, a bit disinclined to stir every printf line, and break tons of other patches, for this.  
3271	28644305	2013-11-17T07:41:25Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28644305	laanwj	@jgarzik That's also why I have discouraged doing this.    On the other hand, it appears pretty trivial to rebase patches to this and it mostly (only) affects debug printing.  
3271	28645089	2013-11-17T09:02:23Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28645089	laanwj	Apart from the above nits I think this is overall a good idea (printf is ugly and un-typesafe after all, so getting rid of it in favor of a safer method reduces risks. Also depending on C99 as well as C++ was a bit weird), but we may want to merge other pull requests first to prevent conflicts.
3271	28649395	2013-11-17T14:27:44Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28649395	sipa	I'd prefer a `CLogStream("class") << ...`, with "class" optional as well.    Since this is something that is often written during debugging, maybe just call it `Log()`?
3271	28649428	2013-11-17T14:29:26Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28649428	sipa	Why remove error's return type?
3271	28649828	2013-11-17T14:54:11Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28649828	brandondahler	Because error always returned false, which made the fact that it returns anything confusing (until you looked up the definition).  Error was a subroutine acting like a function.     > On Nov 17, 2013, at 8:29 AM, Pieter Wuille <notifications@github.com> wrote:  >   > Why remove error's return value?  >   >   > Reply to this email directly or view it on GitHub.
3271	28677269	2013-11-18T06:07:16Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28677269	brandondahler	@sipa and @laanwj:  following your suggestions, I have created the Log class (log.h and log.cpp).  At its core it works by multiplexing an input to multiple outputs.      Since generally flags won't change after instantiation of the class (except for changes from other threads), the constructor of the instantiation reads the different flags and decides what streams to send the data to.    For all types except strings and const char*s, the data is just passed along to the streams below (manipulators work too).  For strings and const char*s, we do a little processing based on what stream it is, specifically seeing if/when we are writing new lines.      For the error function, I removed it all-together and replaced them with log calls ("ERROR: " prepended, "\n" appened).  If we want to make it so the "ERROR: " part is configurable, I would recommend a public static const char* on Log instead of making a wrapping function.
3271	28757904	2013-11-19T01:32:37Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28757904	brandondahler	Fixed problems hopefully, rebased.
3271	28857110	2013-11-20T01:43:26Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28857110	gavinandresen	I prefer printf-style syntax over << " " << etc, so I don't like this pull.  It is 700 extra lines of code for approximately zero practical benefit that I can see.    
3271	28862460	2013-11-20T04:10:50Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28862460	brandondahler	@gavinandresen:  I understand feeling that there is a lot of one-time risk involved in moving from printf to stream style conversion; however, I completely disagree that there is no practical benefit.    1)  This makes maintenance easier    The code is much less complex overall.  This removes some ugly compatibility #defines, attribute markings, and even hacks.    2)  Platform independence    We are no longer relying on the platform to have a correct/compliant printf function.  Instead we are relying on the C++ standard library implementation which we already rely on since we use C++ in the first place.  This is specifically a problem for int64_t since Windows doesn't use the same syntax as Linux unless you use some compatibility defines.    3)  The way it reads    Streams read fluently instead of requiring the user to place the parameters in the correct place.  Consider:        return strprintf(              "HTTP/1.1 %d %s\r\n"              "Date: %s\r\n"              "Connection: %s\r\n"              "Content-Length: %"PRIszu"\r\n"              "Content-Type: application/json\r\n"              "Server: bitcoin-json-rpc/%s\r\n"              "\r\n"              "%s",          nStatus,          cStatus,          rfc1123Time().c_str(),          keepalive ? "keep-alive" : "close",          strMsg.size(),          FormatFullVersion().c_str(),          strMsg.c_str());    Becomes        ossReply << "HTTP/1.1 " << nStatus << " " << cStatus << "\r\n"               << "Date: " << rfc1123Time() << "\r\n"               << "Connection: " << (keepalive ? "keep-alive" : "close") << "\r\n"               << "Content-Length: " << strMsg.size() << "\r\n"               << "Content-Type: application/json\r\n"               << "Server: bitcoin-json-rpc/" << FormatFullVersion() << "\r\n"               << "\r\n"               << strMsg;      return ossReply.str();    Likewise logging lines stand out just like normal cout lines (given the new Log class).    ____    All of this being said, I will agree that the shorter changes, such as:        std::string tmpfn = strprintf("peers.dat.%04x", randv);    Becoming        std::ostringstream tmpfn("peers.dat.");      tmpfn << std::hex << std::setfill('0') << std::setw(4) << randv << std::dec << std::setfill(' ');    Would probably work better off as a boost::format.  The reason I started out with not using boost::format more is because I personally prefer to keep dependence on boost to a minimum.  If y'all disagree I do think it could make things less cluttered when making simple, smalls strings.      Likewise creating formatting functions for specific types of data would allow us to change the output formatting of the data in one place instead of across a bunch of files, while fitting in with the stream style.  Using the above function again, having a static call makes things cleaner all-together:        ...      std::string tmpfn = CAddrDB::PeersFilePath(randv);      ...        std::string CAddrDB::PeersFilePath(unsigned short randv)      {          std::ostringstream tmpfn();          tmpfn << "peers.dat." << std::hex << std::setfill('0') << std::setw(4) << randv;          return tmpfn.str();      }    Further we can make custom manipulators to reduce duplication of code:        ios_base& hex04(ios_base& ib)      {          ib << std::hex << std::setfill('0') << std::setw(4);          return ib;      }            std::string CAddrDB::PeersFilePath(unsigned short randv)      {          std::ostringstream tmpfn();          tmpfn << "peers.dat." << hex04 << randv;          return tmpfn.str();      }  
3271	28862686	2013-11-20T04:18:07Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28862686	brandondahler	On another note, does anyone have any idea why pull tester is failing?  The only lines that look bad are:        =============      1 test passed      =============      make[4]: Leaving directory `/mnt/bitcoin/linux-build/src/test'      make[3]: Leaving directory `/mnt/bitcoin/linux-build/src/test'      make[2]: Leaving directory `/mnt/bitcoin/linux-build/src/test'      make[1]: Leaving directory `/mnt/bitcoin/linux-build/src'      make  check-local      make[2]: Entering directory `/mnt/bitcoin/linux-build'      /bin/mkdir -p qa/tmp      make[2]: *** [check-local] Killed      make[2]: Leaving directory `/mnt/bitcoin/linux-build'      make[1]: *** [check-am] Error 2      make[1]: Leaving directory `/mnt/bitcoin/linux-build'      make: *** [check-recursive] Error 1      tail: `/mnt/bitcoin/linux-build/.bitcoin/regtest/debug.log' has become inaccessible: No such file or directory    From http://jenkins.bluematt.me/pull-tester/fd77e459e07f3684c39b7861e758028ace756456/test.log .  Whereas a successful one shows the following at the same spot:        =============      1 test passed      =============      make[4]: Leaving directory `/mnt/bitcoin/linux-build/src/test'      make[3]: Leaving directory `/mnt/bitcoin/linux-build/src/test'      make[2]: Leaving directory `/mnt/bitcoin/linux-build/src/test'      make[1]: Leaving directory `/mnt/bitcoin/linux-build/src'      make[1]: Entering directory `/mnt/bitcoin/linux-build'      make  check-local      make[2]: Entering directory `/mnt/bitcoin/linux-build'      /bin/mkdir -p qa/tmp      tail: write error: Broken pipe      tail: write error
3271	28867775	2013-11-20T07:07:09Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28867775	laanwj	@gavinandresen Agreed, the problem isn't with printf-style *syntax*, it's with the printf function  - which (in our usage) isn't part of the C++ standard, so we had a dependency on C99-like formats that broke down on Windows without special mingw defines. Also it's not type safe, easy to mess up the stack with some wrong % char, and uses a variable-number-of-parameters hack which breaks down for std::string so a dummy '0' argument is inserted with a macro (the `real_strprintf` etc...).     Many reasons to get rid of the sprintf hacks. But boost::format would be better in that regard as it mostly keeps printf syntax but is typesafe and has none of those mentioned drawbacks.    I don't think the actual risk is that large, at most some debug messages will be formatted differently.    It could map pretty much one-on-one. Could we do this without adding (so many) lines?  
3271	28867859	2013-11-20T07:09:49Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28867859	laanwj	Also -- do we really need our own class for handling time? (bitcointime.cpp/h) How is this related to the subject of this pull?  Reducing depenency on boost is not a goal! If boost offers some functionality, please use that instead of rolling our own.    This changes way too many things, please keep it focused.    
3271	28887312	2013-11-20T13:04:55Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28887312	brandondahler	@laanwj I would not consider the use of ostringstream as "rolling my own", namely because that is the only way provided by the C++ standard library to convert random types to strings and vice versa.    If you are talking about the Log class, the first commit started off without it, but it was added because it simplifies the actual logging process (the business logic that goes in to putting type T data into X, Y, and Z streams) and it makes reading the actual print lines prettier:        Log() << something << " something else";     vs         LogPrint(str(boost::format("%d something else") % something)); ).
3271	29126107	2013-11-23T05:13:43Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/29126107	BitcoinPullTester	Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/ce86ee002d20c7a77cf25bb4468ffd4f62667469 for binaries and test log. This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/ Contact BlueMatt on freenode if something looks broken.
3270	28645291	2013-11-17T09:23:42Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28645291	laanwj	We don't have control over that. If I had, I'd remove the package there.    Please use the PPA instead https://launchpad.net/~bitcoin/+archive/bitcoin  
3269	28661877	2013-11-17T19:47:00Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/28661877	kuzetsa	If those cosmetic changes can be tweaked in a way which doesn't delay the release of this feature, I'm all for it.
6	624966	2010-12-20T17:32:33Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/624966	davout	Deletion is not necessary,  doesn't it already happen anyway when wallet is replaced ?
6	754604	2011-02-09T18:00:28Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/754604	mndrix	Easy import and export of keys would make it easier for trusted vendors to sell Bitcoin stored-value cards (USB sticks, mini CDs, etc) with a private key on them.  The buyer then just imports the private key from the card.    Easy import/export also addresses parts of issue #2
6	816774	2011-02-28T04:32:35Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/816774	gasteve	Easy import/export is an important feature for the day when transactions are no longer free on the network.  People won't want to pay transaction fees when consolidating or moving btc value between different wallets they own.  Also, easy import/export should be treated like moving (rather than copying) to prevent keys from ending up in multiple, concurrently active wallets (backup should be used for ensuring you don't lose keys).  I think I'll create a separate issue for this (since it is straying from this topic).  As for treating the wallet as a generic key store or using existing key store solutions, I think it's better to stay away from that in the short term.  That could pose quite a few technical and integration challenges, and if not done very carefully, could pose a security risk (you would be putting bitcoin users at the mercy of third party key storage solutions that may or may not be very well implemented). 
6	2009365	2011-09-06T06:46:58Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2009365	alexwaters	https://github.com/bitcoin/bitcoin/pull/220 wallet import and export should resolve this issue, please contribute to that thread.
5	742740	2011-02-06T01:25:53Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/742740	tcatm	Anyone thoughts on this? It's now one month old. I'll close it in a few days if no one comments on this.
5	743634	2011-02-06T15:03:05Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/743634	cdecker	Well we do have 4 upvotes, so it is something that has some interest. Generally we should distinguish better between the Protocol and Satoshis client.
5	744034	2011-02-06T18:16:41Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/744034	tcatm	Can you make a patch?
5	744041	2011-02-06T18:19:37Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/744041	cdecker	It's not really something you can "patch", it's all about not increasing the version number in the version message if the update does not break backward compatibility. instead of using the version number use the version string to identify the client and client version.
5	744050	2011-02-06T18:24:11Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/744050	tcatm	Well, a patch would at least add a constant PROTOCOL_VERSION = xyz, wouldn't it?
5	744074	2011-02-06T18:46:15Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/744074	cdecker	I'll look into it ^^  How should I submit it?
5	744096	2011-02-06T18:53:32Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/744096	tcatm	pull request :)
5	760089	2011-02-10T18:21:41Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/760089	cdecker	Ok, submitted the pull request. Please review :D It's not much but this is more of a design change than a code change ^^
5	767127	2011-02-13T07:02:48Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/767127	jgarzik	This seems to be opposite of satoshi's intent.
5	767224	2011-02-13T09:22:02Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/767224	cdecker	Comments moved to pull request.
4	624435	2010-12-20T13:54:43Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/624435	gavinandresen	Is this useful at all if there is no matching import?  (export is pretty easy, the import is what is hard...)
4	624969	2010-12-20T17:34:10Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/624969	davout	Yes, I forgot that
4	625251	2010-12-20T19:01:29Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/625251	davout	Duplicate of #2
3	676264	2011-01-13T23:08:58Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/676264	fabianhjr	I think we can be creative about the way to input the password. IMHO it should be similar to the Android. It is really awesome and forces you into thinking about something more abstract. :)
3	704564	2011-01-25T00:48:32Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/704564	dooglus	How does Android do it?  Got a reference?
3	722969	2011-01-30T19:48:03Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/722969	gavinandresen	I jotted down some thoughts here:   https://gist.github.com/803170  
3	762047	2011-02-11T07:56:13Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/762047	zibalas	I think this is a key feature. Manually backing up and securing your wallet really sucks, I think this keeps a lot of users from using BitCoin. Also there should be possible to specify wallet location. This way I would keep my wallet in my dropbox and therefore would take care of backing up.
3	769319	2011-02-14T05:22:31Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/769319	jeffWelling	The Andriod way of inputting your passcode (assuming you mean what you think I mean) is kind of a 'connect the dot' system, where you slide your finger from the first digit directly to the second.  This has the implication of actually being less secure than using the traditional tap per digit system, because it limits the number of neighboring digits to 8 as opposed to the full 10. With the andriod way, if the first digit for your password is 5, then your possible choices for a second digit are 1,2,3, 4 and 6, and 7,8,9.  However, consider what happens when your starting digit is 1, your next available digits become 2, 4 and 5. With the traditional method, no matter what key you start on, you may choose any other 0-9 number. I do applaud the creativity and innovation, but I think the security implications need to be pointed out.  I would like if my wallet was encrypted taking advantage of my already existing GnuPG key. :)
3	804745	2011-02-24T08:56:04Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/804745	ghost	Suppose we encrypt keys with the public key of a separate private key. That private key is encrypted with a symmetric algorithm, whose key is derived from the passphrase. I believe this is how GnuPG works. When we store this encrypted key in the wallet, we also store a reference to the associated private key. (Or, perhaps have it elsewhere on the file system... usb drive? smart card? keyring?) With this functionality, we could prompt the user for a password once and decrypt multiple keys. It also means that a wallet could be separated into virtual partitions with different encryption keys. I think it would allow a smooth transition, but would it be backwards compatible?[1]  Here's the way I imagine interacting with this. I would keep a small amount of bitcoin in the clear. This allows me to easily spend the small amount while assuring I won't lose much if my device is compromised (good for mobile devices). I can easily encrypt/decrypt keys by entering a target amount to "transfer". The actual amount is determined by picking keys with transactions (outputs?) summing to approximately the target. In order to spend more than is in the clear, I must enter one (or more) passphrases, but the rest is automated.  [1]Can the structure of the wallet be modified for encrypted keys and a reference to the encrypting private key without causing a breaking change?
3	839341	2011-03-06T08:16:52Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/839341	jhyslop	Fnordsoft, I hope the GPG mechanism is simpler - the pass phrase is hashed into a symmetric key, and that key is used to encrypt the sensitive data in the wallet. Much simpler, and you don't have to worry about storing a private key anywhere. The user enters the pass phrase, and the program checks it by encrypting something with the public key, then decrypting it with the private key, and ensuring that the resulting 'something' matches the original 'something'.    As for the input, keep it simple: there's nothing wrong with the plain ol' keyboard. The Android style may work well on a mobile device, but would be a royal pain in the *** anywhere else.      
3	839377	2011-03-06T08:40:29Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/839377	jeffWelling	jhyslop, but many of us already use GnuPG with public key cryptography, so we're already storing private keys which we use for other purposes. Adding one more key is trivial.     I see no reason why both symmetric and public key cryptography couldn't be available as an option.  Aside from the obvious "who will program it" part.
3	840031	2011-03-06T16:27:34Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/840031	jhyslop	OK, I see what you're getting at, Jeff. Yeah, that could be an option. The default, I think, should be to use the hashed pass phrase as a symmetric key, with an option to allow advanced users to provide a public key.
3	840093	2011-03-06T16:55:14Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/840093	jhyslop	By the way, just to clarify - when I said "the default should be to use the hashed pass phrase as a symmetric key" (HPPASK) I wasn't necessarily pushing HPPASK as The Solution. To generalize my statement, what I meant was "the default should be some password mechanism that keeps the wallet self-contained, and by the way the HPPASK seems to me a simple solution that meets the needs."  
3	850304	2011-03-09T03:56:03Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/850304	genjix	Couldn't find how to assign myself tickets, but I'm working on this. So give me a couple of weeks (focus on other issues) if possible ;)  (don't like duplicating work). BTW I'm using a symmetric key (AES now, but easy to switch to blowfish .etc) with the passphrase hashed with RSA using OpenSSL. If you're interested then run 'man evp_sealinit' or man evp_openinit.
3	911394	2011-03-24T07:48:12Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/911394	thiloplanz	An alternative (or stop-gap measure) to encrypting the wallet could be to allow the user to specify where the file should be. This way, he can place it on an encrypted volume (that he may already have for other important documents).
3	1071393	2011-04-28T18:37:45Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1071393	borneq	My proposal: wallet.dat zipped and encrypted. How effective is break password by brute force? One step can require verify all file?
3	1092188	2011-05-03T05:40:00Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1092188	benlake	First time user experience. I am a developer, but would like to shed light on what I encountered when discovering the world of Bit Coins.  After reading a taste of what BCs were I download the client (developer side) and fired it up (OSX). I was met with a string of characters not too frightening for a developer and especially not when expecting crazy encryption fun times to be going on. However, I didn't quite know what I was looking at or what it meant to me. I stumbled onto Bit Faucet and it introduced the notion that these characters were an address used to receive BC. So I learned something. At some point I clicked "New..." and my string of characters changed; this befuddled me a bit. Some more reading calmed me as it was "good practice" to generate these new addresses and use them liberally.  As I continued to learn about what I had gotten myself into it came to light that the client I had downloaded was the key to whatever BTC I began to acquire. So as a developer, my first questions were, "where is the secret key?", "how do I protect it?", and "how do I move it and still use this client?". All of these questions are being touched on in IRC and in this thread. So I'm glad to see the discussion is taking place. However, I have yet to see reasonable discourse that talks about what sort of experience our target end-user should see. When starting a conversion in IRC #bitcoin-dev about the above questions I quickly received answers such as: "just backup your wallet.dat file", "use truecrypt", "use gpg", "use a USB stick or dropbox", et cetera. My response is... DUH! The point of the discourse was not to get an answer I am perfectly capable of doing _as a developer_. It was to discuss how to make Bit Coins and the associated software accessible to our girlfriends, mothers, and fathers. So, with all of that context, and as a development brother looking at my experience as a first time user (while it is still fresh, I discovered BC two days ago and now have 40BTC, yay), I'd like to suggest the following:  * Do NOT generate the secret magic sauce upon the client first loading, instead, provide an introduction screen that says, "Hey, welcome to the world of Bit Coins! Let's walk through a few concepts before you get started". Introduce the high-level concepts of: 1) you will be creating a wallet, 2) you generate "addresses" which others use to send you Bit Coins 3) your wallet is the key to accessing your Bit Coins, if you create another wallet on a different device, you will have two different "accounts" (like at a different bank) * Prompt the user to create a wallet, have the default directory available, but at least introduce them to where this super sensitive information is. Then show a generating magic sauce message with a repeated explanation that THIS IS IMPORTANT * I personally suggest _integrating_ TrueCrypt as a sub-system of the BC client. Use a true crypt volumes to store either just the sensitive files or everything (good when using a portable USB key). Prompt the user to enter a passphrase so the true crypt volume can be created and used. People are used to passwords, opening the BC client and being prompted for a password by default won't alarm anyone. * True Crypt has done work to be used on portable devices. I recommend Bit Coin do the same and be completely runnable via a USB stick. * Provide a GUI level option to "backup your wallet" (ie. make a copy of the true crypt volume somewhere else). It would also be handy to be able to name your wallets and prominently display it in the client. When backing up the name would default to "Wallet Backup 2011-02-16" and the wallet would be marked as a backup. If a client opens a backup wallet, a warning could be issued stating as much and asking if this should now be considered a primary wallet (in the event of a restore)  My suggestions focus on education and features crucial to the adoption of Bit Coins, in my opinion. I cannot feel good about telling a non-techy about Bit Coins without these features. I want to be able to tell my girlfriend and her be able to make sense of the experience on her own. Thanks for all of the hard work thus far and I'm really enjoying my foray into the Bit Coins community.  Cheers,
3	1092524	2011-05-03T07:57:47Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1092524	borneq	If TryCrypt give anything? It joins file as disk. This disk is readable to other programs (trojans), only advantage TryCrypt is defense against read wallet.dat when someone steals computer.
3	1093972	2011-05-03T13:58:57Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1093972	benlake	As far as I see, this discussion was not about malicious software on the device in which the wallet.dat file was being stored. Trojans could be a problem now, and you are correct, they could be a problem when using True Crypt. To clarify, the goal of using True Crypt is as you said, to protect against theft when one no longer has access to their device OR when the bit coin client is not running (in this case, trojans mean nothing).  Not to derail the conversation onto malware, but I see no reason to have the wallet.dat file (or other sensitive files) open when not needed. I cannot speak to the internals of how the wallet.dat file is used, but I would summise there could be a way of "locking" or un-mounting the True Crypt disk when the client is not using it and prompting when necessary. That could get annoying, but more discussion on real-time protections should be in another thread. As I see it, this discussion concerns some level of inherent encryption built into the client. To be fair, my mentions of "backups" should be in another thread as well, but the topics tend to be mentioned together.  Thank you for the opportunity to clarify.
3	1246585	2011-05-27T01:13:55Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1246585	alexgenaud	Encrypted or not, I strongly advocate a plaintext wallet. Encryption DOES NOT help backup the wallet. It does mean (to a minor extent) that you don't need to be quite as careful with where you backup, but you should ALWAYS backup.  As it is, I've got multiple copies of three wallet files on the same media because I am too scared to delete some of them, despite the fact that the addresses are redundant. I can not 'diff' the files, so my backup solution is just copy copy copy. If I ever need to recover, I'll probably have to load a hundred versions of all my wallets looking for loose change. If the wallet were plain text, I'd keep ONLY the key pairs I need and never duplicate them (on the same media).  For similar reasons I disagree with the keypool=100 hack because it presents a false sense of security. Eventually (after the 100th key pair) a restoration from backup will blow away real money.  And yes, you can have plain text and encryption as a radix64 key block.
3	1389561	2011-06-17T17:21:04Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1389561	l337r007	I'd love to see a scheme like in SSH, where the private keys can be encrypted, and a password is then required for using them. Make it optional for all I care, but personally if someone should be able to obtain my wallet.dat it should be useless to them without an extensive amount of work (say brute-forcing my password).  Keep private keys encrypted on disk, decrypt for usage (where usage is "signing an outgoing transaction"), and wipe the memory area after use.  To be a bit more technical; HPPASK is pretty much the scheme of choice, with a resource-intensive hash like PBKDF2 with lots of rounds... +1
3	1764850	2011-08-09T16:25:09Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1764850	gavinandresen	Encrypting private keys pulled.  Closing this request.
2	625250	2010-12-20T19:01:12Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/625250	davout	File should be human-readable
2	780992	2011-02-17T06:23:55Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/780992	mgiuca	Seconded. I have been using Bitcoin for a couple of days, and while many users will not care about the details, I want to know (at least during my initial testing of the system) exactly how it works. This will help me, and other tech-savvy users understand the security implications.  To me, the biggest "black box" of the whole system is the wallet. It's a binary blob which I am told to keep backed up or else. It's unclear to me how I would restore it without erasing recent transactions. I'm not sure which data is stored in it and which is not -- from the look of some other bugs here, it seems to store more data than just the public/private keys (such as config data). Does it store the names I have associated with the addresses? (I wouldn't want to lose my PC, restore my wallet.dat, and discover I can't tell who sent me what, so I'd hope it does store those names.) Does it store sending addresses? (I don't think it should, as that's more of an address book than a crucial wallet.) And it isn't encrypted with a password.  I'm not asking for answers to these questions -- I can find them out if I really want to. I'm saying that these answers should be immediately obvious from inspecting the wallet file. There should be nothing "magical" about this file, for an advanced user.  I would like to see a transition to a "Wallet 2.0" file format, which is simply a PGP-encrypted text file (so, binary, but a simple gpg -d will get the text out). I should be able to encrypt it with either a symmetric or public key.  Inside the file, there would be a simple ASCII format, such as: &lt;address&gt; (active|inactive) [name] &lt;pub-key&gt; &lt;priv-key&gt;  with one address per line (or split into "sections" if the pub-key and priv-key are too long to put on a single line). The active|inactive determines whether the address shows up as a receive address in the GUI (so when it pre-generates 100 addresses, they all show up here, and are all marked inactive until the user presses "New Address" in the UI).  This would only contain receiving addresses. Sending addresses would be in a separate address book file, which would hopefully also be a text file, and I could back up too if I wanted to but isn't critical.  Now, at a glance, I (as a technical user) can tell exactly what data is stored in the wallet. And it should be significantly easier to write tools for listing all the money associated with each account in the wallet, splitting up a wallet into separate files, and so on.
2	838824	2011-03-06T01:28:23Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/838824	Kiv	Agree about human readable, I would love to actually understand the contents of my wallet. 
2	840714	2011-03-06T21:21:19Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/840714	gavinandresen	See my bitcointools tree for a (python) tool that dumps out the information in the wallet in a human-readable form.  
2	864570	2011-03-12T22:31:02Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/864570	sipa	I'm currently working on a patch that will allow export and import of wallets in a human readable form.  The format i've been using currently has lines of this form: [privatekey] [block nr of earlest unredeemed output to this key] # [address] [available BTC]  The part after the # is optional, since only the private key suffices, the rest can be derived, The block number was suggested by Gavin on the forum somewhere, as an optimization.  Maybe adding address labels is useful as well.
2	864895	2011-03-13T01:41:09Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/864895	mgiuca	There has been some discussion relating to a so-called ".bitkeys" format, which would be a standardised human-readable text file format for storing Bitcoin private key data. It seems to have been suggested here by [mike]:  [http://www.bitcoin.org/smf/index.php?topic=3638.40](http://www.bitcoin.org/smf/index.php?topic=3638.40)    I don't know if the format discussion has moved elsewhere, but you should try to be compatible with this format.    Basically, this means your file should start with v=1 (version, I assume). Exporter should write v=1, importer should check for v=1.    Otherwise, what you suggest is almost right, but the private key and block number should be comma-separated:  base58 encoded privkey,block number  # comment    Everything after the hash is a comment. You said it was "optional" but that sort of implies that your software will possibly be looking for an address and available BTC. It should not, since the format should allow arbitrary machine-ignored text after the #. So your exporter should write # [address] [available BTC] or whatever you want, but your importer should completely ignore everything after the comment and just use the privatekey to derive the public key and address.    Also note, if you haven't written the code for this already, that I already implemented, in C using OpenSSL, the code to take a 32-byte private key and generate the full 279-byte DER key (which Bitcoin internally calls the "private key") and 65-byte public key. My intention was for my code to eventually be used inside Bitcoin itself, so please use it if you can:    * [bitcoin-import Bazaar branch](https://code.launchpad.net/~mgiuca/+junk/bitcoin-import)  * [priv_der.c](http://bazaar.launchpad.net/~mgiuca/+junk/bitcoin-import/view/head:/priv_der.c)    It is currently a command-line program which takes the private key as input and produces the DER key (of which the public key is a substring), but it is very well documented and could easily be adapted into a bitkeys file reader.
2	864958	2011-03-13T02:27:05Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/864958	sipa	Sure, that thread is where i got the idea, i couldn't remember where it was. The code for importing and exporting private keys also already exists, see http://www.bitcoin.org/smf/index.php?topic=3906. The hard part is keeping the data structures in bitcoind intact and up to date when importing things.  The precise formatting is only a detail that can easily be changed. Clearly, the importer will ignore everything after a #, as the address and available BTC to an address can be derived from the private key and the block chain, but still useful for human readers, so the exporter will put them in comments.  Maybe we should start the format discussion again, since there are additional useful things to put in such a file, it seems. Whether or not the key is only a reserve key, a possible label for a key, ... 
2	17040180	2013-04-25T21:02:41Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/17040180	APerson241	+1 on human-readable.
2	17056823	2013-04-26T05:56:12Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/17056823	laanwj	No +1ing here please. If you comment, add something substantial. Otherwise, code or gtfo :)  
2	17056871	2013-04-26T05:58:36Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/17056871	jgarzik	I think this issue is too vague and outside the scope of what we normally consider issues/pull reqs, these days.  Recommend closing.
2	17063592	2013-04-26T09:28:41Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/17063592	Diapolo	@jgarzik ACK
1	745944	2011-02-07T13:43:11Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/745944	rasos	Yes, very important. If we enable mobile devices, pocket wallets will be soon obsolete ;-) GUI for smart-phones should include some QR reader, such as portapayment.com 
1	968464	2011-04-07T11:43:38Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/968464	thiloplanz	"Submit signed transactions to the network"  I want that as well, for Google App Engine, where you cannot participate in the regular peer-to-peer protocol, because you cannot open sockets. Having something like an XMPP proxy that pushes signed transactions into the peer network would be cool. Maybe the existing IRC channel can also be used for that.
1	2103909	2011-09-15T12:35:03Z	https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2103909	Stemby	I offer 1 BTC bounty.    Regards,  Carlo
