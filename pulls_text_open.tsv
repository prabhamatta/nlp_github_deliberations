3297	- cleanup Info.plist.in and specify high DPI mode enable command as per - move setting of QApplication::setAttribute() to bitcoin.cpp and add attribute for enabling use of high DPI pixmaps for Qt >= 5.1 - add missing setWindowTitle() on Mac - cleanup Mac / non-Mac setup in bitcoingui.cpp
3296	This shows subvers and IPs in the log lines that track mempool / connect activity. It makes it easier to see strange nodes.
3295	qa/rpc-tests/wallet.sh runs a three-node -regtest network, generates a fresh blockchain, and then exercises basic wallet sending/receiving functionality using command-line RPC. Depends on #3294
3294	Im writing some wallet regression tests using -regtest mode, and need to generate an initial multi-hundred-block chain. Repeatedly calling setgenerate to generate one block is slow and doesnt work properly, because block creation happens asynchronously. This adds two features to setgenerate in -regtest mode: 1) Instead of being interpreted as number of threads to start, the third argument is the number of blocks to generate. 2) setgenerate will not return until the block creation threads have created the requested number of blocks.
3286	- in the address validator a string < address length is considered intermediate - in the validated line edit add an isAcceptable() check on focus out of the field, which kicks in, when a validator is used with the line edit - remove an isAcceptable() check from sendcoinsentry.cpp
3285	- remove monospace labels from sendcoinsdialog also - use a validated line edit for the change address - add a tooltip to change address switch - ensure we have a valid change address in CoinControlDialog::coinControl->destChange or just CNoDestination() - some small ui file changes
3284	Split bitcoinrpc up into - rpcserver: bitcoind RPC server - rpcclient: bitcoin-cli RPC client - rpcprotocol: shared common HTTP/JSON-RPC protocol code One step towards making bitcoin-cli independent from the rest of the code, and thus a smaller executable that doesnt have to be linked against leveldb. This commit only does code movement, there are no functional changes.
3281	Add "destdata" record type to wallet, as well as accessor functions on CWallet and CWalletDB. This can be used by the UI to store arbitrary data tuples to be associated with a tx destination in the wallet. A destdata tuple in the wallet is of the form (address, key, value) where the key acts to distinguish different types of generic data. The purpose of this is to give the GUI a way to store: - When an address table record was created (for #3207) - The invoice Payment URI associated with a receiving address (for #3207) - Outgoing payment requests (as soon as the GUI for this is ready), so that they can be associated with incoming transaction outputs when paid (transaction details could show this information...) And possibly other data later. Ill add tests when this is deemed a sane change.
3277	- implement CAutoFile via std::fstream and use it in the code - unify log/error messages for serializing/deserializing exceptions - add debug and benchmark messages for writing/reading block/undo files - remove boost::path member from CAddrDB class - add new helper functions GetBlockFile() and GetUndoFile() If considered usefull, Im open to feedback and comments. Ive been using this for ages with my local build and never had any problems with it. I know that currently there is no "flush to disk" when downloading blocks, but perhaps this can help investigating the Mac corruption problems.
3276	Currently, the protocol processing happens mostly in main, while most of its data structures are defined in net. This leads to weird situations where they need to access eachothers locks, and it is unclear what functionality belongs where. This pull request introduces a main-specific CNodeState, which is managed entirely by main, so doesnt require CNodes locks. The intention is to move all processing-related fields in CNode to CNodeState, so ultimately main doesnt need access to CNode anymore, decoupling the two. This is a long way out, and well probably want to separate protocol processing to a different module than block validation, but its what we have now. For now, only node banning is moved to CNodeState. The reason for this is asynchronous processing. When blocks or transactions are processed by background threads, or in any way not directly the result of a single message being processed, we may want to attribute errors still to the original senders DoS score. Going back and forth between main and net for this becomes increasingly ugly, as this can be done perfectly well inside main. The direct motivation for this is an attempt at implementing BIP37-filtered-block-based fetching, and headers-first.
3273	Make users accustomed to the other subdivision units (mBTC, muBTC) by showing the total amount in all units in the confirmation dialog. This was recently raised on the mailing list and could be a preparation for switching over the default unit eventually. ![allunits](https://f.cloud.github.com/assets/126646/1558415/c6f324ae-4f8e-11e3-91ac-88e2705c32db.png)
3271	Convert aoti[64] to fromstr, itostr[64] to tostr. Add CLogStream (logstream.h), wraps ostringstream but preserved type after insertions. Use fstream where possible (when no fsync is required). Change error function to have void return type. Fix functions relying on the false return from error function. Use boost::format for localized string token replacement. Follow up for #3236, #3237, and #3244. This should remove C99 requirements. Replaces *printf functions with C++ equivalents.
3265	- prevents the client to handle payment requests that do not match the clients network and shows a warning instead (was mainly a problem with drag&drop payment requests onto the client window)
3254	- make eventFilter() private and pass events on to QObject::eventFilter() instead of just returning false - re-work paymentservertest.cpp to correctly handle the event test after the above change (rewrite test_main to allow usage of QCoreApplication:: in the tests) - delete socket when we were unable to connect in ipcSendCommandLine() - show a message to the user if we fail to start-up (instead of just a debug.log entry) - misc small comment changes
3242	
3239	This is the first half of the smart fee rework. Three commits; the first two are clean-up refactors. The third adds an optional boolean verbose flag to getrawmempool, and reworks the memory pool to store CTxMemPoolEntrys instead of CTransactions. Output of getrawmempool true is an Object, with transaction id keys: ``` "f5f67700586e435a8634f6235783936cb015a11115f2d379fb987e34d21d58bd" : { "size" : 223, "fee" : 0.0050000, "time" : 1384221652, "height" : 269117, "startingpriority" : 0.00000000, "currentpriority" : 313.90134529, "depends" : [ "6fcad339f1a613594e9e9f877772a6c3896493ea7babf286a054421190761efa" ] }, ``` EDITED: store/report timestamp when the transaction entered the pool. Shed-painting on whether this should return an Array of Objects (with "txid" one of the keys) instead of an Object welcome, as are suggestions for key names (e.g. prefer startingpriority or prioritystart).
3229	As discussed on IRC, this removes the "defaults" miners often use as an excuse to not make mining decisions. getblocktemplate is disabled unless bitcoind is explicitly configured with mining settings.
3207	Continuation of work in #3099. Keep a list of requested payments in the Receive tab so that a user can recall previously created receive requests after closing their windows. Currently this list is not stored between bitcoin-qt sessions. This can be implemented later, but it is not clear here it should be stored as I dont think it belongs in the wallet (maybe in QSettings?) at least until it is really associated with a transaction. ![recently_requested](https://f.cloud.github.com/assets/126646/1475793/dc78e68a-4640-11e3-812b-3f39978099c4.png)
3178	- replaces a pwalletMain->IsLocked() check - in keypoolrefill init kpSize to 0 as we have the logic to determine max kpSize in pwalletMain->TopUpKeyPool() anyway
3157	Related to #3159 and #3160 (same changes for transactionview and walletview). Goal: Harmonize user experience for export of addresses, transactions and backup of the wallet! ![export_addr](https://f.cloud.github.com/assets/1419649/1414006/c2433602-3e62-11e3-8743-bbb0f3ad0599.png)
3147	
3088	This patch eliminates the privacy and reliability problematic use of centralized web services for discovering the nodes addresses for advertisement. The Bitcoin protocol already allows your peers to tell you what IP they think you have, but this data isnt trustworthy since they could lie. So the challenge is using it without creating a DOS vector. To accomplish this we adopt an approach similar to the one used by P2Pool: If were announcing and dont have a better address discovered (e.g. via UPNP) or configured we just announce to each peer the address that peer told us. Since peers could already replace, forge, or drop our address messages this cannot create a new vulnerability... but if even one of our peers is giving us a good address well eventually make a useful advertisement.
3025	This fixes another malleability problem.
3005	Addresses the last (I believe) work-item in Im unsure of the correct fix here, but I hope this can at least get some discussion going. This change at least fixes the problem on the surface. Heres the summary as I see it: Theres a mix of current-proxy-setting and saved-proxy-setting logic. Assuming the proxy is currently enabled: User unchecks the proxy checkbox, hits apply, the dialog checks to see what the new proxy setting should be, GetProxy() returns true because its currently enabled, check remains in the checkbox, user is confused. Logically (to me) it makes sense to be checking the setting rather than the current runtime values, as the setting should reflect what user sees on next restart. But there are plenty of other GetProxy()/SetProxy() calls, so Im inclined not to trust that line of reasoning.
2975	Suggested by gmaxwell.
2966	vtxPrev was intended to make it possible to broadcast supporting transactions. For various reasons it doesnt actually accomplish this goal while still consuming a sizable amount of space in the wallet. Ive removed most references to vtxPrev and replaced them with procedures that pull transactions from mapWallet. As a side effect this code includes similar performance improvements to CWalletTx::IsConfirmed as
2910	This is a proposed solution for the "Fingerprint via weak-chain block submission" issue (#2757). Before storing a block, a check is done to see if it is at a height lower than last checkpoint. If so, it is not stored. (By definition, last checkpoint implies we have the whole chain up until last checkpoint, so we do not need to store any new blocks at those heights). A similar check is done before serving a request for a block at a pre-checkpoint height. If its not in the main chain, it could be a fingerprint block. There is no point serving this block to anyone as it is a fork from the checkpointed chain, so the request is dropped. Although fingerprinting would be possible by generating a block higher than last checkpoint, it would be economically prohibitive to do so.
2906	Makes it possible to test nodes against bitcoind and to test bitcoinds misbehavior detection without having to constantly restart bitcoind.
2900	Lets nodes advertise that they offer bloom filter support explicitly. The protocol version bump allows SPV nodes to assume that NODE_BLOOM is set if NODE_NETWORK is set for pre-70002 nodes. Also adds an undocumented option to turn bloom filter support off and immediately kick peers that attempt to use bloom filters for testing purposes. In addition a number of DoS attacks are made significantly easier by bloom support, so having an option makes it easy to take immediate steps in the event of an attack.
2861	A rebased and modified version of #2121. Changes: * Support P2SH addresses, so listunspent/signrawtransaction can be used without having all keys for M-of-N multisig. * Add a fRequireSpendable flag to scripts matching routines, so watch-only addresses can be avoided. This is used in SelectCoins (CreateTransaction would fail to sign them anyway). * Different storage format in database, which supports P2SH too.
2844	The beginnings of a block explorer-style API for bitcoind. Supported API; 1) GET /rest/tx/TX-HASH.{dat | txt | json} Given a transaction hash, Returns a transaction, in binary, hex-encoded binary or JSON formats. 2) GET /rest/block/BLOCK-HASH.{dat | txt | json} Given a block hash, Returns a block, in binary, hex-encoded binary or JSON formats. Select format by appending a ".json" (JSON) or ".txt" (hex-encoded binary serialization) or ".dat" (binary serialization) suffix to the URL. ``` GET /rest/block/BLOCK-HASH.dat GET /rest/tx/TX-HASH.txt GET /rest/tx/TX-HASH.json ``` The HTTP request and response are both handled entirely in-memory, thus making maximum memory usage at least 3MB (1 MB max block, plus hex encoding) per request. This can be easily accessed via command line cURL/wget utilities. The general goal of the HTTP REST interface is to access unauthenticated, public blockchain information. There is no plan to add wallet interfacing/manipulation via this API. For full TX query capability, one must enable the transaction index via "txindex=1" command line / configuration option.
2841	One of the most annoying things about trying to maintain wallet backups is the fact that every time you unlock a wallet the key pool gets automatically refilled, thus making any existing backups of the wallet keys obsolete. If you call getnewaddress on a locked wallet, no problem - but the moment you unlock it, your wallet backups are out of date...no warning is given to user. Sooner or later that backed up wallet will expire, by which time we better hope the user had the foresight, understanding, discipline, and memory to have made a new backup. As things currently stand, the user must either keep track of when the backed up keypool is exhausted and remember to make a backup before the new keys are used - or must make a backup after every few transactions to be certain the backed up keypool is never exhausted. And lets be honest about it - very few users do either of these things. They are tedious and annoying. I only do them because theyre far less tedious or annoying than attempting to recover lost keys. The user now has the choice to disable automatic refilling of the keypool by adding the following line to bitcoin.conf: noautofillkeypool=1 This effectively disables all automatic key generation, requiring the user to manually run keypoolrefill to replenish the wallet when the key pool runs low or a new wallet is created.The keypoolrefill command has been conveniently exposed in the GUI as well. This ensures that all generated keys can be easily and conveniently backed up in a timely fashion, with confidence that the backup has been made properly and will never expire without warning (at least as far as keys - synchronizing history and account labels are separate issues that this pull request does not address). We probably shouldnt be allowing users to generate new keys without prompting them to make backups (or automatically making the backups for them); certainly not in the GUI and probably not in the RPC either (at least not without requiring an override flag or an additional call). It obviously makes more sense to do backups in batch rather than after every single new transaction; after all, thats exactly the purpose of pregenerating a key pool in the first place. I believe hiding this from users only does them a disservice. Anyone who is smart enough to use Bitcoin-Qt should have no problem understanding how to do this - and anyone who is incapable of doing this probably shouldnt be managing their own bitcoin keys in the first place. EVERYONE should be making proper backups of their signing keys. Exposing a wallet backup function without also giving users control over their keypool is giving them a tool that requires two hands to use properly but tying one of their hands behind their back. This pull request simply makes the keypool feature which already exists properly usable. Having said that, with the expectation that some may disagree with my position, this new behavior is 100% opt-in - if noautofillkeypool is not set in bitcoin.conf (or omitted), the app defaults to its old behavior thus ensuring full backward compatibility. ![alt tag](http://blockhawk.net/screenshots/Bitcoin-Qt.png) View of Bitcoin-Qt interface with keypoolrefill feature exposed. TODO: - General: Automate backups when keypool runs low by, for instance, allowing the user to add one or more autobackupwallet=\<destination\> lines to the config file. The destination field should support protocols like sftp as well as removable media. Will require mechanism to prompt user or return an error if connection cannot be established, removable media is not present, or specified path is not found/invalid. - Bitcoin-Qt: Prompt user to refill pool when key pool is empty, prompt/remind user more aggressively to make backups, check key pool status before attempting operations that require new keys, add indicator to show how many keys are left in pool, add the ability to easily change the pool size from GUI, make it clear when errors are due to an empty key pool and show user proper procedure for refilling it and making a backup. - Bitcoin-Qt: Icon attribution for ![alt tag](https://github.com/CodeShark/bitcoin/diff_blob/6b18ba00d265f544dd457a83fac0c930ae51c66a/src/qt/res/icons/keypair.png?raw=true), taken from
2839	This is a rebased version of a patch that mining.bitcoin.cz used during the march 11 2013 hardfork, to be able to continue using 0.8 while still mining the 0.7 chain. The reason for submitting it to mainline is: * When implementing this, I found that there were a few edge-cases in the reorganization handling, which are fixed here. They probably wont ever occur in normal operation, but I prefer the code to be robust. * For emergencies, having a blacklistblock RPC is certainly useful to have in the code, though I prefer not having it in normal releases. Its only enabled when compiling with ENABLE_BLOCK_BLACKLISTING. The RPC code is always compiled, so we can catch refactorings that would break it, though - just the index entry is not present normally.
2834	Resubmission of #1355, since GitHub closed it on me. I have rebased it and addressed both of concerns: - Shutdown now disconnects all longpoll sessions with an error. - Longpolling now mimicks the behaviour of BitcoinMiner by returning a new template after a minute has passed and there are new transactions. These changes were not exactly trivial, so re-review of the code is probably necessary.
2784	Ping automatically every 2 minutes (unconditionally), instead of of after 30 minutes of no sending, for latency measurement and keep-alive. Also, disconnect if no reply arrives within 5 minutes, instead of after 90 minutes of inactivity. This should make detection of stalled connections much faster.
2612	- add new options for database cache and script verification threads - add new options for setting separate IPv6 and Tor proxy and show for which networks the base proxy is used currently - add label which displays options that are overridden by command-line parameters - proxy settings are not applied on-the-fly anymore and require a client restart (ApplyProxySettings() was removed and was not working very well anyway) - re-work options reset and require a client shutdown (as it is much easier to do it this way without having to mess with what can be changed on-the-fly and what needs a restart anyway) - options reset now writes default values for every single option - when changing an option which requires a client restart display a 10 second warning message in statusLabel (via a QTimer) - when applying the changes via ok change that to a persistent message, which is displayed even after closing optionsdialog and re-open it, when no client restart was made - remove dialog boxes used when changing language or proxy settings - add setRestartRequired() and isRestartRequired() to OptionsModel and use the set function when updating options to signal OptionsDialog when a restart is needed - resize optionsdialog a little and add some min sizes for certain GUI elements - remove apply button from optionsdialog - save and restore optionsdialog window position - update nTransactionFee in QSettings with a set -paytxfee value when opening optionsdialog (Im not sure about this yet, perhaps revert to not updating QSettings and just display current -paytxfee value in optionsdialog.)
2575	- rework the proxy handling in init to cover more cases and work more thoroughly - add -proxy6 to allow setting a separate SOCKS5 proxy to reach peers via IPv6 - add a hard-block for -tor to be able to remove compatibility code - rework proxy data-structures to allow recognition of the default proxy (-proxy) to give users the ability to see, which proxy (IPv6 / Tor) is derived from the default proxy and which was explicitly set - remove proxy info from RPC getinfo call - add new getproxyinfo RPC call Most proxy-setup is now done using the new ``ProxyInit()`` function. ``ProxyInit(Network net, const std::string& strArg, int nSocksVersion, bool fIsDefault)`` parameter description: ``net`` = network to setup proxy for (NET_IPV4, NET_IPV6 or NET_TOR) ``strArg`` = command-line argument to get values from (-proxy, -proxy6 or -onion) ``nSocksVersion`` = SOCKS version of the proxy ``fIsDefault`` = is that proxy the default proxy (true) or a separate proxy (false)? ``ProxyInit(Network net, const std::string& strArg, int nSocksVersion, bool fIsDefault)`` does the following: -pre-check, if ``net`` is not limited and -no{proxy/proxy6/tor} was NOT specified --pre-check passed: try to ``SetProxy()`` and return ``false`` on error ---pre-check passed: only for ``net == NET_TOR`` call ``SetReachable();`` ---pre-check passed: return ``true`` --pre-check failed: for default proxy (``fIsDefault == true``) a failed pre-check is okay, return ``true``, otherwise ``false`` default proxy = ``-proxy`` separate IPv6 proxy = ``-proxy6`` separate Tor proxy = ``-onion`` Proxy initialisation flow (happens via ``ProxyInit()``, just the name proxy is special cased in the code): -try to setup default IPv4 proxy --if SOCKS4: ---try to setup separate Tor proxy, on failure disable Tor via ``SetLimited()`` (SOCKS4 = no Tor support) ---try to setup separate IPv6 proxy, on failure disable IPv6 via ``SetLimited()`` (SOCKS4 = no IPv6 support) --if SOCKS5 ---try to setup separate Tor proxy, on failure try to setup Tor proxy via default proxy ---try to setup separate IPv6 proxy, on failure try to setup IPv6 proxy via default proxy ---try to setup default SOCKS5 name proxy Errors initialising default proxy or Tor/IPv6 proxies via default proxy lead to exit!
2412	Allow the network activity of the client to be toggled temporarily. When network activity is disabled the client will close all connections, stop accepting inbound connections, and stop opening new outbound connections, until the network activity is reenabled. The first commit adds this feature to the core, accessed through SetNetworkActive(). Second commit adds an RPC command "togglenetwork" to toggle on/off. Third commit adds further connections to the gui. When the network activity is disabled the status bar and the debug window will show this. In addition the commit adds a button to the debug window to toggle network activity. ![bitcoin-network-activity](https://f.cloud.github.com/assets/420734/301091/75019bd4-95bd-11e2-91f2-c37c05891b31.png) Open issues: * Should the core close the listening socket or is it enough to just disregard incoming connections by closing them immediately? * Should SetNetworkActive() return an error code or can it throw exceptions?
2407	This pull request is a minimal step in the direction of merging The idea is to merge things incrementally rather than all at once.
2342	Basically AcceptBlock() checks IsFinal() for transactions in a block with nHeight of the block being tested, or essentially nBestHeight+1 however CreateNewBlock() was using just nBestHeight, so transactions were being included into blocks one block later than they could be. Additionally the new IsFinal() test in IsStandard() had the same issue, as well as the UI. (ironically, a fix I wrote a few months ago, lead astray by simply watching to see when transactions got mined on testnet) The bug in CreateNewBlock() is especially nasty for fidelity bond sacrifice transactions, because a miner who knew the trick could collect all the fees for himself, one block before anyone else had a chance. (subject to hash power of course) Anyway, I should update the patch with unittests and investigate the issue more carefully; for instance, have there ever been any nLockTimed transactions ever mined in the main chain at the minimum possible block? Also, can the same logic be fixed for time-locked transactions?
2340	Set nLockTime on wallet transactions (only, no RPC changes) such that they can only be mined by the next block, rather than a block orphaning the current best block. There are two reasons to do this, the first is the minor benefit that using nLockTime ensures related bugs get caught immediately, so protocols that need that feature dont become "unusual" transactions with flaky behavior. The more important reason is to discourage "fee sniping" by deliberately mining blocks that orphan the current best block. Basically for a large miner the value of the transactions in the best block and the mempool can exceed the cost of deliberately attempting to mine two blocks to orphan the best block. However with nLockTime youll soon run out of transactions you can put in the first block, which means they now need to go in the second. With limited block sizes youre run out of room, and additionally another miner now only needs to orphan one block to in-turn snipe the high-fee transactions you had to place in the second block, wrecking all your hard work. Of course, the subsidy is high enough, and transaction volume low enough, that fee sniping isnt a problem yet, but by implementing a fix now we ensure code wont be written that makes assumptions about nLockTime that preclude a fix later. Transaction propagation is not impacted; even with non-final is non-standard the best block height implies we have at least one peer, and very soon more peers, that will accept and rebroadcast the transaction immediately. ## Testing ### Unit tests Pass ### Propagation No issues. Used -blocknotify=bitcoind sendtoaddress to send transactions as soon as a few block is found with worst-case of a node connected to only two 0.8 peers. Enabled -logtimestamps w/ ntp on that node and another node, and every transaction got to the second node within 5 seconds. ### Services No problems: Easywallet, Instawallet, Coinbase Wallet, Coinbase Merchant Services, Blockchain.info, BitPay, bitfetch, localbitcoins Wont accept until 1 confirmation: Satoshidice Most likely SatoshiDice implemented nLockTime == 0 rather than IsFinal() as their never-confirm nLockTime fix. I think there is an argument to be made that forcing them to make a minor change like this one would be a good way to test the waters to see if theyll make a more drastic change, as would be required if we make dust outputs non-standard.
2124	bitcoind now supports loading more than one wallet at once. A singleton object of type CWalletManager now exists. It handles dynamic loading/unloading and synchronization of wallets and allows different parts of the application to access wallets by name. A new CWallet* parameter has been added to the RPC functions. Functions which do not use a wallet simply ignore it. In addition, a new field has been added to CRPCCommand that tells us whether or not the function can be called on a wallet. Wallet-specific information has been removed from RPC method getinfo. Instead, getinfo just reports how many wallets are currently loaded. Detailed wallet info is now available via the listwallets method. Four new RPC methods have been added: - listwallets Returns an array containing wallet information. - usewallet \<walletname\> \<method\> [params] Allows you to apply existing RPC commands to different wallets. A default wallet named the empty string is always loaded and is used if calls are made without usewallet. Example: bitcoind usewallet foo listreceivedbyaddress 0 true (thanks, gmaxwell, for the idea) - loadwallet \<walletname\> [rescan=false] [upgradewallet=false] [maxversion=(latest)] Dynamically loads an existing wallet file wallet-\<walletname\>.dat. If no wallet file exists a new wallet is created. The default wallet file is always called wallet.dat. - unloadwallet \<walletname\> To specify additional wallets at startup, use option -usewallet=foo -usewallet=bar etc...as detailed here: and TODO: - Clean up I/O in CWalletManager::LoadWallet - debug, error, and UI output functions. - Check synchronization code. - Test mining functionality. Allow RPC mining on arbitrary wallets. - Integrate with Qt.
1816	This would aide greatly in ensuring miners arent messing up blocks, without the expense of losing 50 BTC.
1674	- change our hardening options to use -fstack-protector-all even for Windows builds, as we recently switched to a newer compiler suite - also removes an obsolete workaround for GCC 4.5 (https://bugs.launchpad.net/ubuntu/+source/gcc-4.5/+bug/691722), which required to first set -fno-stack-protector, before -fstack-protector-all
1647	**Status: Passes unit tests, and seems to work** Consider parent transactions in the "cost" of child transactions until confirmed, and confirm them together This is the part of #1240 that left out of #1590 since he felt it belonged in a separate commit/pullreq.
1583	Accepts the transaction into mined blocks at a higher (or lower) priority
